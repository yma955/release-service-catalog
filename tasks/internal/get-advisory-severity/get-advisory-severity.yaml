---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: get-advisory-severity
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |
      This task gets the advisory severity. It does this by querying OSIDB for each CVE present in the
      releaseNotesImages. For each CVE, the overall impact it is looked at. If the OSIDB entry lists an
      impact for the specific affected component, that is used instead of the overall impact. The highest
      impact from all of the CVEs is returned as a task result.
  params:
    - name: releaseNotesImages
      type: string
      description: Base64 string of gzipped JSON array of image specific details for the advisory
    - name: internalRequestPipelineRunName
      type: string
      description: name of the PipelineRun that called this task
  results:
    - name: result
      description: Success if the task succeeds, the error otherwise
    - name: severity
      description: The advisory severity level
    - name: internalRequestPipelineRunName
      description: Name of the PipelineRun that called this task
    - name: internalRequestTaskRunName
      description: Name of this Task Run to be made available to caller
  volumes:
    - name: osidb-service-account-vol
      secret:
        secretName: osidb-service-account
        defaultMode: 0400
  steps:
    - name: get-advisory-severity
      image: quay.io/konflux-ci/release-service-utils:002e438fd71196a7b4613308025358476acc1f8e
      computeResources:
        limits:
          memory: 32Mi
        requests:
          memory: 32Mi
          cpu: '1'  # 1 is the max allowed by at least the staging cluster
      volumeMounts:
        - name: osidb-service-account-vol
          mountPath: /mnt/osidb-service-account
      env:
        - name: IMAGES_ENCODED
          value: $(params.releaseNotesImages)
      script: |
          #!/usr/bin/env bash
          set -eo pipefail

          SERVICE_ACCOUNT_NAME="$(cat /mnt/osidb-service-account/name)"
          SERVICE_ACCOUNT_KEYTAB="$(cat /mnt/osidb-service-account/base64_keytab)"
          OSIDB_URL="$(cat /mnt/osidb-service-account/osidb_url)"

          set -x

          STDERR_FILE=/tmp/stderr.txt
          echo -n "$(params.internalRequestPipelineRunName)" > "$(results.internalRequestPipelineRunName.path)"
          echo -n "$(context.taskRun.name)" > "$(results.internalRequestTaskRunName.path)"

          # shellcheck disable=SC2317 # shellcheck calls all the commands in exitfunc unreachable because it is called
          # via trap
          exitfunc() {
              local err="$1"
              local line="$2"
              local command="$3"
              if [ "$err" -eq 0 ] ; then
                  echo -n "Success" > "$(results.result.path)"
              else
                  echo -n \
                    "$0: ERROR '$command' failed at line $line - exited with status $err" > "$(results.result.path)"
                  if [ -f "$STDERR_FILE" ] ; then
                      tail -n 20 "$STDERR_FILE" >> "$(results.result.path)"
                  fi
              fi
              exit 0 # exit the script cleanly as there is no point in proceeding past an error or exit call
          }
          # due to set -e, this catches all EXIT and ERR calls and the task should never fail with nonzero exit code
          trap 'exitfunc $? $LINENO "$BASH_COMMAND"' EXIT

          echo -n "" > "$(results.severity.path)"

          # Decode and decompress the releaseNotesImages data
          IMAGES=$(echo "${IMAGES_ENCODED}" | base64 --decode | gzip -d)

          # write keytab to file
          set +x
          echo -n "${SERVICE_ACCOUNT_KEYTAB}" | base64 --decode > /tmp/keytab
          set -x
          # workaround kinit: Invalid UID in persistent keyring name while getting default ccache
          KRB5CCNAME=$(mktemp)
          export KRB5CCNAME
          KRB5_CONFIG=$(mktemp)
          export KRB5_CONFIG
          export KRB5_TRACE=/dev/stderr
          sed '/\[libdefaults\]/a\    dns_canonicalize_hostname = false' /etc/krb5.conf > "${KRB5_CONFIG}"
          retry 5 kinit "${SERVICE_ACCOUNT_NAME}" -k -t /tmp/keytab

          INCLUDE_FIELDS="cve_id,impact,affects.purl,affects.impact"
          ADVISORY_SEVERITY=""
          CVE_CACHE_DIR=$(mktemp -d)

          get_higher_severity() { # Return higher sev of the two provided [current highest, new]
              if [ "$1" == "CRITICAL" ] || [ "$2" == "CRITICAL" ] ; then
                  echo "CRITICAL"
              elif [ "$1" == "IMPORTANT" ] || [ "$2" == "IMPORTANT" ] ; then
                  echo "IMPORTANT"
              elif [ "$1" == "MODERATE" ] || [ "$2" == "MODERATE" ] ; then
                  echo "MODERATE"
              elif [ "$1" == "LOW" ] || [ "$2" == "LOW" ] ; then
                  echo "LOW"
              else
                  # To get here, the one we are comparing against is an invalid value, so just
                  # return $1, which is the current highest severity
                  echo "$1"
              fi
          }

          # Function to process a batch of CVEs with its own token
          process_cve_batch() { # Expected arguments are [batch_id, batch_cves]
              echo "Batch $1: Getting token..."
              set +x
              batch_token=$(curl --retry 3 --negotiate -u : "${OSIDB_URL}"/auth/token | jq -r '.access')
              if [[ -z "$batch_token" || "$batch_token" == "null" ]]; then
                  echo "Batch $1: ERROR - Failed to obtain authentication token" | tee -a "$STDERR_FILE"
                  exit 1
              fi
              set -x

              echo "Batch $1: Processing CVEs..."

              while read -r cve; do
                  if [[ -n "$cve" ]]; then
                      cache_file="$CVE_CACHE_DIR/${cve}.json"

                      # Note: If we bypass this check in a race condition, the output from OSIDB will be
                      # the same anyways so it is safe - multiple batches writing identical data is harmless
                      if [[ -f "$cache_file" ]]; then
                          continue  # Already processed
                      fi

                      echo "Batch $1: Processing CVE ${cve}"
                      curl_url="${OSIDB_URL}/osidb/api/v1/flaws?cve_id=${cve}&include_fields=${INCLUDE_FIELDS}"
                      set +x

                      # Try API call with current token, refresh and retry if it fails
                      if ! curl --retry 3 \
                          -H 'Content-Type: application/json' \
                          -H "Authorization: Bearer ${batch_token}" \
                          "$curl_url" | jq '.results[0]' > "$cache_file"; then
                          echo "Batch $1: API call failed, refreshing token and retrying..."
                          batch_token=$(curl --retry 3 --negotiate -u : "${OSIDB_URL}"/auth/token | jq -r '.access')
                          if [[ -z "$batch_token" || "$batch_token" == "null" ]]; then
                              echo "Batch $1: ERROR - Failed to obtain authentication token" | tee -a "$STDERR_FILE"
                              exit 1
                          fi
                          curl --retry 3 -H 'Content-Type: application/json' -H "Authorization: Bearer ${batch_token}" \
                              "$curl_url" | jq '.results[0]' > "$cache_file"
                          # Validate cache file was written with valid data
                          if [[ ! -s "$cache_file" ]] || [[ "$(cat "$cache_file")" == "null" ]] ; then
                              echo "Batch $1: ERROR - Querying OSIDB for CVE $cve failed" | tee -a "$STDERR_FILE"
                              exit 1
                          fi
                      fi
                      set -x
                  fi
              done <<< "$2"

              echo "Batch $1: Completed"
          }

          ALL_CVES=$(jq -r '[.[] | select(.cves.fixed) | .cves.fixed | keys[]] | unique | .[]' <<< "${IMAGES}" \
            | tr "\n" " ")

          # Convert to array for batching
          read -ra ALL_CVES_ARRAY <<< "$ALL_CVES"
          TOTAL_CVES=${#ALL_CVES_ARRAY[@]}

          BATCH_SIZE=30
          NUM_BATCHES=$(( (TOTAL_CVES + BATCH_SIZE - 1) / BATCH_SIZE ))
          MAX_PARALLEL_BATCHES=8
          CURRENT_JOBS=0

          echo "Processing $TOTAL_CVES unique CVEs in $NUM_BATCHES parallel batches of $BATCH_SIZE CVEs each"

          for ((i = 0; i < NUM_BATCHES; i++)); do
              START_IDX=$((i * BATCH_SIZE))
              BATCH_LENGTH=$BATCH_SIZE

              # Adjust batch length for last batch
              if [[ $((START_IDX + BATCH_SIZE)) -gt $TOTAL_CVES ]]; then
                  BATCH_LENGTH=$((TOTAL_CVES - START_IDX))
              fi

              if [[ $BATCH_LENGTH -gt 0 ]]; then
                  # Create batch CVE string (simple bash array slice)
                  BATCH_CVES=$(printf '%s\n' "${ALL_CVES_ARRAY[@]:$START_IDX:$BATCH_LENGTH}")

                  # Start batch in background
                  process_cve_batch "$i" "$BATCH_CVES" &
                  CURRENT_JOBS=$((CURRENT_JOBS + 1))

                  # If we've reached the limit, wait for any job to complete
                  if [[ $CURRENT_JOBS -ge $MAX_PARALLEL_BATCHES ]]; then
                      if ! wait -n; then
                          echo "ERROR: Batch processing failed - stopping remaining jobs" | tee -a "$STDERR_FILE"
                          exit 1
                      fi
                      CURRENT_JOBS=$((CURRENT_JOBS - 1))
                  fi
              fi
          done

          # Wait for all remaining batches to complete
          while (( CURRENT_JOBS > 0 )); do
              if ! wait -n; then
                  echo "ERROR: Batch processing failed - stopping remaining jobs" | tee -a "$STDERR_FILE"
                  exit 1
              fi
              CURRENT_JOBS=$((CURRENT_JOBS - 1))
          done

          echo "All CVE data retrieved"

          # Now process images using cached CVE data
          NUM_IMAGES=$(jq 'length' <<< "${IMAGES}")
          for ((i = 0; i < NUM_IMAGES; i++)); do
              image=$(jq -c --argjson i "$i" '.[$i]' <<< "${IMAGES}")
              repository=$(jq -r '.repository' <<< "$image")
              NUM_CVES=$(jq '.cves.fixed | length' <<< "$image")
              for ((j = 0; j < NUM_CVES; j++)); do
                  cve=$(jq -r --argjson j "$j" '.cves.fixed | to_entries[$j].key' <<< "${image}")
                  echo "Checking CVE ${cve} for component with repository ${repository}"

                  # Read saved CVE data
                  if ! OUTPUT=$(cat "$CVE_CACHE_DIR/${cve}.json") ; then
                      echo "ERROR: CVE ${cve} not found in cache - batch processing failed" | tee -a "$STDERR_FILE"
                      exit 1
                  fi

                  IMPACT=$(jq -r '.impact' <<< "$OUTPUT")
                  # If there is a component specific impact, use that instead
                  # To check if it is the same component, we use the repository value and match it with the
                  # repository_url field in the purl from OSIDB. Thus, we have to check each entry as
                  # repository_url is not its own field
                  NUM_AFFECTED_COMPONENTS=$(jq '.affects | length' <<< "$OUTPUT")
                  for ((k = 0; k < NUM_AFFECTED_COMPONENTS; k++)); do
                      AFFECTED_COMPONENT=$(jq --argjson k "$k" '.affects[$k]' <<< "$OUTPUT")
                      PURL=$(jq -r '.purl // ""' <<< "$AFFECTED_COMPONENT")
                      # .purl can be empty, so we direct stderr and just have it return empty string if purl was empty
                      AFFECTED_REPOSITORY=$(python3 -c "from packageurl import PackageURL; \
                        print(PackageURL.from_string('$PURL').to_dict()['qualifiers']['repository_url'])" \
                        2> /dev/null || true)
                      if [ "$AFFECTED_REPOSITORY" == "$repository" ] ; then
                          COMPONENT_IMPACT=$(jq -r '.impact // ""' <<< "$AFFECTED_COMPONENT")
                          # If we found a component specific impact, use that
                          if [ -n "$COMPONENT_IMPACT" ] ; then
                              IMPACT="$COMPONENT_IMPACT"
                          fi
                          break
                      fi
                  done
                  ADVISORY_SEVERITY=$(get_higher_severity "$ADVISORY_SEVERITY" "$IMPACT")
              done
          done

          if [ -z "$ADVISORY_SEVERITY" ] ; then
              echo "Unable to find severity on any cve listed in the releaseNotes" | tee -a "$STDERR_FILE"
              exit 1
          fi

          # Change from all caps to just first letter capitalized
          ADVISORY_SEVERITY="${ADVISORY_SEVERITY,,}"
          ADVISORY_SEVERITY="${ADVISORY_SEVERITY^}"
          echo -n "$ADVISORY_SEVERITY" > "$(results.severity.path)"
          exit 0
