---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: filter-already-released-advisory-images-task
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |
    Filters out images from a snapshot if they are already published in an advisory
    stored in the GitLab advisory repo. Returns a list of component names
    that still need to be released (i.e., not found in any advisory).
  params:
    - name: transformedSnapshot
      type: string
      description: Base64 string of gzipped JSON representation of architecture-specific images from snapshot
    - name: origin
      description: The origin workspace for the release CR
      type: string
    - name: advisory_secret_name
      description: Name of the secret containing advisory metadata
      type: string
    - name: internalRequestPipelineRunName
      description: Name of the PipelineRun that requested this task
      type: string
  results:
    - name: result
      description: Success or error message
    - name: internalRequestPipelineRunName
      description: The name of the InternalRequest PipelineRun
    - name: internalRequestTaskRunName
      description: The name of the InternalRequest TaskRun
    - name: unreleased_components
      description: List of components that still need to be released encoded as a gzipped base64 string
    - name: advisory_url
      description: URL of the latest matching advisory when all components are already released
    - name: advisory_internal_url
      description: Internal URL of the latest matching advisory when all components are already released
  volumes:
    - name: advisory-secret
      secret:
        secretName: $(params.advisory_secret_name)
        defaultMode: 0400
  steps:
    - name: filter-images
      image: quay.io/konflux-ci/release-service-utils:0b2f257d7a5c2a881c36c23f8ae3cd5e89db593a
      computeResources:
        limits:
          memory: 256Mi
        requests:
          memory: 256Mi
          cpu: 500m
      volumeMounts:
        - name: advisory-secret
          mountPath: /mnt/advisory_secret
      env:
        - name: TRANSFORMED_SNAPSHOT
          value: "$(params.transformedSnapshot)"
      script: |
        #!/usr/bin/env bash
        set -eo pipefail

        GITLAB_HOST="$(cat /mnt/advisory_secret/gitlab_host)"
        # This is a GitLab Project access token.It should have the Developer role with read
        # and write repository rights.
        ACCESS_TOKEN="$(cat /mnt/advisory_secret/gitlab_access_token)"
        GIT_AUTHOR_NAME="$(cat /mnt/advisory_secret/git_author_name)"
        GIT_AUTHOR_EMAIL="$(cat /mnt/advisory_secret/git_author_email)"
        GIT_REPO="$(cat /mnt/advisory_secret/git_repo)"

        # export the variables used by the scripts in release-service-utils
        export GITLAB_HOST ACCESS_TOKEN GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL

        STDERR_FILE=/tmp/stderr.txt
        echo -n "$(params.internalRequestPipelineRunName)" > "$(results.internalRequestPipelineRunName.path)"
        echo -n "$(context.taskRun.name)" > "$(results.internalRequestTaskRunName.path)"

        exitfunc() {
          local err=$1
          local line=$2
          local cmd=$3
          if [ "$err" -eq 0 ]; then
            echo -n "Success" > "$(results.result.path)"
          else
            echo -n "$0: ERROR '$cmd' failed at line $line - exited with status $err" > "$(results.result.path)"
            if [ -f "$STDERR_FILE" ]; then tail -n 20 "$STDERR_FILE" >> "$(results.result.path)"; fi
          fi
          exit 0
        }
        trap 'exitfunc $? $LINENO "$BASH_COMMAND"' EXIT

        TRANSFORMED_SNAPSHOT_JSON=$(base64 -d <<< "$TRANSFORMED_SNAPSHOT" | gunzip)

        echo "Transformed Snapshot JSON (arch-specific): $TRANSFORMED_SNAPSHOT_JSON"

        ORIGIN="$(params.origin)"
        ADVISORY_BASE_DIR="data/advisories/${ORIGIN}"

        cd /tmp

        echo "Cloning $GIT_REPO..."
        # Use sparse checkout to only get the advisory directory
        git clone --depth=1 --filter=blob:none --no-checkout "$GIT_REPO" repo
        cd repo
        git sparse-checkout set "$ADVISORY_BASE_DIR"
        git checkout

        echo "Checking existing advisories in ${ADVISORY_BASE_DIR}..."
        EXISTING_ADVISORIES=""
        if [ -d "${ADVISORY_BASE_DIR}" ]; then
          EXISTING_ADVISORIES=$(
            find "${ADVISORY_BASE_DIR}" -mindepth 2 -type d -printf "%T@ %p\n" |
            sort -nr | cut -d' ' -f2- | sed "s|^${ADVISORY_BASE_DIR}/||"
          )
        fi

        if [[ -z "$EXISTING_ADVISORIES" ]]; then
          echo "No existing advisories found. No components have been released yet."
          # Extract unique component names from transformed snapshot
          UNRELEASED_COMPONENTS=$(echo "$TRANSFORMED_SNAPSHOT_JSON" \
            | jq -c '[.[].name] | unique' \
            | gzip -c \
            | base64 -w 0)
          echo -n "$UNRELEASED_COMPONENTS" > "$(results.unreleased_components.path)"
          echo -n "" > "$(results.advisory_url.path)"
          echo -n "" > "$(results.advisory_internal_url.path)"
          echo -n "Success" > "$(results.result.path)"
          exit 0
        fi

        # Track the latest advisory that contains matching content
        # EXISTING_ADVISORIES is sorted by modification time (newest first)
        LATEST_ADVISORY_FILE=""

        EXISTING_CONTENT=/tmp/existing_content.json
        # Use a mutable working set for progressive filtering across advisories
        ARCH_IMAGES="$TRANSFORMED_SNAPSHOT_JSON"
        for ADVISORY_SUBDIR in $EXISTING_ADVISORIES; do
          ADVISORY_FILE="${ADVISORY_BASE_DIR}/${ADVISORY_SUBDIR}/advisory.yaml"
          yq -o=json '.spec.content.images // []' "$ADVISORY_FILE" > "$EXISTING_CONTENT"

          echo "Comparing against: $ADVISORY_FILE"

          # Check if this advisory contains any matching content before filtering
          ARCH_IMAGES_BEFORE_FILTER="$ARCH_IMAGES"

          # Filter arch-specific images using original triple-match logic
          ARCH_IMAGES=$(echo "$ARCH_IMAGES" | jq --slurpfile existing "$EXISTING_CONTENT" '
            map(select(
              .containerImage as $ci |
              .tags as $tags |
              .repository as $repo |
              ($existing[0] | map(select(
                .containerImage == $ci and .tags == $tags and .repository == $repo
              )) | length == 0)
            ))')

          ARCH_IMAGES_BEFORE_COUNT=$(jq 'length' <<< "$ARCH_IMAGES_BEFORE_FILTER")
          ARCH_IMAGES_AFTER_COUNT=$(jq 'length' <<< "$ARCH_IMAGES")
          if [[ $ARCH_IMAGES_BEFORE_COUNT -gt $ARCH_IMAGES_AFTER_COUNT ]]; then
            if [[ -z "$LATEST_ADVISORY_FILE" ]]; then
              LATEST_ADVISORY_FILE="$ADVISORY_FILE"
              FILTERED_COUNT=$((ARCH_IMAGES_BEFORE_COUNT - ARCH_IMAGES_AFTER_COUNT))
              echo "Tracked latest advisory: $LATEST_ADVISORY_FILE (filtered $FILTERED_COUNT items)"
            fi
          fi

          # If no arch images remain, all components are released
          if jq -e 'length == 0' <<< "$ARCH_IMAGES" >/dev/null; then
            echo "All arch images in the snapshot have already been released in advisories. Stopping pipeline."
            echo -n "[]" | gzip -c | base64 -w 0 > "$(results.unreleased_components.path)"
            
            echo "Returning advisory: $LATEST_ADVISORY_FILE"
            ADVISORY_TYPE=$(yq -r '.spec.type' "$LATEST_ADVISORY_FILE")
            ADVISORY_NAME=$(yq -r '.metadata.name' "$LATEST_ADVISORY_FILE")
            
            if [[ "${GIT_REPO}" == *"/rhtap-release/"* ]]; then
              ADVISORY_URL_PREFIX="https://access.stage.redhat.com/errata"
            else
              ADVISORY_URL_PREFIX="https://access.redhat.com/errata"
            fi
            
            LATEST_ADVISORY_URL="${ADVISORY_URL_PREFIX}/${ADVISORY_TYPE}-${ADVISORY_NAME}"
            LATEST_ADVISORY_INTERNAL_URL="${GIT_REPO//\.git/}/-/raw/main/${LATEST_ADVISORY_FILE}"
            
            echo -n "$LATEST_ADVISORY_URL" > "$(results.advisory_url.path)"
            echo -n "$LATEST_ADVISORY_INTERNAL_URL" > "$(results.advisory_internal_url.path)"
            echo -n "Success" > "$(results.result.path)"
            exit 0
          fi
        done

        # Extract unique component names from remaining arch images
        ORIGINAL_ARCH_COUNT=$(echo "$TRANSFORMED_SNAPSHOT_JSON" | jq 'length')
        REMAINING_ARCH_COUNT=$(echo "$ARCH_IMAGES" | jq 'length')
        echo "Filtered out $((ORIGINAL_ARCH_COUNT - REMAINING_ARCH_COUNT)) arch-specific image(s) already in advisories"
        echo "Remaining unpublished arch images: $ARCH_IMAGES"

        # Map back to original components and get unique names
        UNRELEASED_COMPONENTS=$(echo "$ARCH_IMAGES" | jq -c '[.[].name] | unique' | gzip -c | base64 -w 0)
        echo -n "$UNRELEASED_COMPONENTS" > "$(results.unreleased_components.path)"
        echo -n "" > "$(results.advisory_url.path)"
        echo -n "" > "$(results.advisory_internal_url.path)"
        echo -n "Success" > "$(results.result.path)"
