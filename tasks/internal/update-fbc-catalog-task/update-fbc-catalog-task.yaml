---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: update-fbc-catalog-task
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton task to submit a IIB build request to add/update fbc-fragments to an index image
  params:
    - name: fbcFragments
      type: string
      description: FBC fragments built by Konflux as JSON array (e.g. ["fragment1", "fragment2"])
    - name: fromIndex
      type: string
      description: >-
        Index image (catalog of catalogs) the FBC fragment will be added to
    - name: buildTags
      type: string
      description: >-
        List of additional tags the internal index image copy should be
        tagged with
    - name: addArches
      type: string
      description: List of arches the index image should be built for
    - name: buildTimeoutSeconds
      type: string
      default: "3600"
      description: Timeout seconds to receive the build state
    - name: iibServiceAccountSecret
      type: string
      description: Secret with IIB credentials to be used
    - name: publishingCredentials
      type: string
      description: Secret containing the publishing credentials used to fetch the image config
    - name: mustPublishIndexImage
      type: string
      default: "false"
      description: Whether the index image should be published (pre-determined by prepare-fbc-parameters)
    - name: mustOverwriteFromIndexImage
      type: string
      default: "false"
      description: Whether to overwrite the from index image (pre-determined by prepare-fbc-parameters)
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  results:
    - name: jsonBuildInfo
      description: JSON build information for the requested build
    - name: buildState
      description: IIB Service build state
    - name: indexImageDigests
      description: The digests for each arch for the manifest list of the index image
    - name: iibLog
      description: The link to the log from the IIB request
    - name: exitCode
      description: The exit code from the task
  volumes:
    - name: service-account-secret
      secret:
        secretName: $(params.iibServiceAccountSecret)
        defaultMode: 0444
    - name: iib-services-config-vol
      secret:
        secretName: iib-services-config
        defaultMode: 0444
    - name: iib-overwrite-fromimage-credentials-vol
      secret:
        secretName: iib-overwrite-fromimage-credentials
        defaultMode: 0444
    - name: publishing-credentials-vol
      secret:
        optional: true
        secretName: $(params.publishingCredentials)
        defaultMode: 0444
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
  stepTemplate:
    volumeMounts:
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true

  steps:
    - name: update-fbc-catalog-prepare-and-call-iib-step
      image: >-
        quay.io/konflux-ci/release-service-utils@sha256:f10b4ad888634a7633f76ede29003ce1471aec2b76a7d9e01ad282a3011eb78f
      securityContext:
        runAsUser: 1001
      computeResources:
        limits:
          memory: 512Mi
        requests:
          memory: 512Mi
          cpu: '1'
      volumeMounts:
        - name: service-account-secret
          mountPath: /mnt/service-account-secret
        - name: iib-services-config-vol
          mountPath: /mnt/iib-services-config
        - name: iib-overwrite-fromimage-credentials-vol
          mountPath: /mnt/iib-overwrite-fromimage-credentials
        - name: publishing-credentials-vol
          mountPath: /mnt/publishing-credentials
      env:
        - name: FBC_FRAGMENTS
          value: $(params.fbcFragments)
      script: |
        #!/usr/bin/env bash

        IIB_SERVICE_URL="$(cat /mnt/iib-services-config/url)"
        KRB5_CONF_CONTENT="$(cat /mnt/iib-services-config/krb5.conf)"

        IIB_OVERWRITE_FROM_INDEX_USERNAME="$(cat /mnt/iib-overwrite-fromimage-credentials/username)"
        IIB_OVERWRITE_FROM_INDEX_TOKEN="$(cat /mnt/iib-overwrite-fromimage-credentials/token)"

        PUBLISHING_CREDENTIAL_PATH="/mnt/publishing-credentials/targetIndexCredential"
        if [ -f "${PUBLISHING_CREDENTIAL_PATH}" ] && [ -s "${PUBLISHING_CREDENTIAL_PATH}" ]; then
          PUBLISHING_CREDENTIAL="$(cat "${PUBLISHING_CREDENTIAL_PATH}")"
        else
          PUBLISHING_CREDENTIAL=""
        fi

        # checks if there is any previous build for the same set of fbc_fragments.
        # fragments are sorted for comparison to ensure consistent matching.
        # in case multiple builds are found, returns only the last one.
        # shellcheck disable=SC2329 # function is called later in this script
        check_previous_build() {
          user="${1}"
          from_index="${2}"
          fbc_fragments_json="${3}"
          current_build_tags="${4:-[]}"  # PLR identifier tags from add-fbc-contribution

          # Step 1: Look for completed builds using server-side state filtering which allows us
          completed_build=$(curl -s "${IIB_SERVICE_URL}/builds?user=${user}&from_index=${from_index}&state=complete" | \
            jq --argjson fbc_fragments "${fbc_fragments_json}" \
              '[.items[] |
                select(.fbc_fragments != null) |
                select((.fbc_fragments | sort) == $fbc_fragments) |
                select(.distribution_scope == "prod" or .distribution_scope == null)
              ] | sort_by(.updated) | last // empty')

          if [ -n "${completed_build}" ] && [ "${completed_build}" != "null" ]; then
            # Validate completed build freshness (existing logic remains unchanged)
            indexImageResolved="$(jq -r '.index_image_resolved' <<< "${completed_build}")"
            newCatalogCreatedDate="$(date --date "$(skopeo inspect \
              --retry-times 3 --config "docker://${indexImageResolved}" | \
              jq -r .created)" "+%s")"

            create_auth_file
            # Try to get from_index creation date for freshness validation
            # First attempt: use the tag directly
            fromIndexCreated="$(skopeo inspect --retry-times 3 --config "docker://${from_index}" 2>/dev/null | \
              jq -r .created)"

            # If tag inspection failed, try using from_index_resolved from the completed build
            if [ -z "${fromIndexCreated}" ] || [ "${fromIndexCreated}" = "null" ]; then
              fromIndexResolved="$(jq -r '.from_index_resolved // empty' <<< "${completed_build}")"
              if [ -n "${fromIndexResolved}" ] && [ "${fromIndexResolved}" != "null" ]; then
                fromIndexCreated="$(skopeo inspect --retry-times 3 --config \
                  "docker://${fromIndexResolved}" 2>/dev/null | jq -r .created)"
              fi
            fi

            if [ -n "${fromIndexCreated}" ] && [ "${fromIndexCreated}" != "null" ]; then
              upstreamCatalogCreatedDate="$(date --date "${fromIndexCreated}" "+%s")"
              if [ "${newCatalogCreatedDate}" -lt "${upstreamCatalogCreatedDate}" ]; then
                echo "WARNING: Completed build is older than from_index, skipping reuse" >&2
                return 0
              fi
            else
              # Could not verify freshness via skopeo - check IIB to see if this build is still the latest
              # for this from_index. If no newer builds exist, we can safely reuse it regardless of age.
              completedFromIndex="$(jq -r '.from_index // empty' <<< "${completed_build}")"
              buildUpdated="$(jq -r '.updated // empty' <<< "${completed_build}")"

              if [ "${completedFromIndex}" = "${from_index}" ] && [ -n "${buildUpdated}" ]; then
                # Query IIB for all builds with the same from_index (regardless of fbc_fragments)
                # If a newer build exists, from_index was updated by another product and we should
                # reject to avoid race conditions where we'd remove fragments from the published catalog.
                all_builds_data=$(curl -s \
                  "${IIB_SERVICE_URL}/builds?user=${user}&from_index=${from_index}&state=complete")

                if [ -n "${all_builds_data}" ] && [ "${all_builds_data}" != "null" ]; then
                  # Extract the last build (most recent, regardless of fbc_fragments)
                  last_build_updated=$(echo "${all_builds_data}" | jq \
                    '[.items[] |
                      select(.distribution_scope == "prod" or .distribution_scope == null) |
                      select(.updated != null and .updated != "")
                    ] | sort_by(.updated) | reverse | .[0].updated // empty')

                  # Compare: if last build is newer than our candidate, from_index was updated
                  # Use numeric comparison (Unix timestamps) to avoid locale-dependent string comparison
                  if [ -n "${last_build_updated}" ] && [ "${last_build_updated}" != "null" ] && \
                     [ "${last_build_updated}" != "${buildUpdated}" ]; then
                    buildUpdatedSeconds="$(date --date "${buildUpdated}" "+%s" 2>/dev/null || echo "0")"
                    lastBuildUpdatedSeconds="$(date --date "${last_build_updated}" "+%s" 2>/dev/null || echo "0")"

                    if [ "${lastBuildUpdatedSeconds}" -gt "${buildUpdatedSeconds}" ]; then
                      echo "ERROR: Could not verify from_index freshness via skopeo, and a newer build " \
                        "exists for this from_index (last build: ${last_build_updated}, candidate: " \
                        "${buildUpdated}). Skipping reuse to avoid race condition where concurrent " \
                        "build updated from_index." >&2
                      return 0
                    fi
                  fi

                  # No newer builds found - this build is still the latest for this from_index
                  # Safe to reuse regardless of age
                  echo "WARNING: Could not verify from_index freshness via skopeo, but IIB confirms " \
                    "no newer builds exist for this from_index. Proceeding with reuse." >&2
                else
                  # IIB query failed or returned empty - cannot verify, reject for safety
                  echo "ERROR: Could not verify from_index freshness via skopeo, and IIB query " \
                    "failed or returned empty. Skipping reuse for safety." >&2
                  return 0
                fi
              else
                # Missing required fields for IIB verification
                echo "ERROR: Could not verify from_index freshness via skopeo, and cannot validate " \
                  "via IIB (missing from_index or updated timestamp). Skipping reuse for safety." >&2
                return 0
              fi
            fi

            # Completed build is valid for reuse
            echo "${completed_build}"
            return 0
          fi

          # Step 2: Look for in-progress builds with PLR collision prevention
          if [ "${current_build_tags}" != "[]" ] && [ -n "${current_build_tags}" ]; then
            in_progress_build=$(curl -s \
              "${IIB_SERVICE_URL}/builds?user=${user}&from_index=${from_index}&state=in_progress" | \
              jq --argjson fbc_fragments "${fbc_fragments_json}" \
                 --argjson current_tags "${current_build_tags}" \
                '[.items[] |
                  select(.fbc_fragments != null) |
                  select((.fbc_fragments | sort) == $fbc_fragments) |
                  select(.distribution_scope == "prod" or .distribution_scope == null) |
                  select(.build_tags != null and ($current_tags | length > 0) and
                         (. as $build | $current_tags | map(. as $tag | $tag | IN($build.build_tags[])) | any))
                ] | sort_by(.updated) | last // empty')

            if [ -n "${in_progress_build}" ] && [ "${in_progress_build}" != "null" ]; then
              echo "${in_progress_build}"
              return 0
            fi
          fi

          # No suitable build found
          return 0
        }

        create_auth_file() {
          mkdir -p "${HOME}/.config/containers"
          fromIndex="$(params.fromIndex)"
          authName="${fromIndex%:*}"

          # registry-proxy.engineering.redhat.com typically doesn't require credentials
          # or uses Kerberos authentication (which skopeo doesn't support via auth.json)
          if [[ "${authName}" =~ ^registry-proxy(\-stage)?.engineering.redhat.com ]]; then
            # Remove any existing auth entry for this registry to avoid skopeo using invalid credentials
            # If auth.json doesn't exist or is empty, create an empty one
            if [ -f "${HOME}/.config/containers/auth.json" ]; then
              jq "del(.auths.\"${authName}\")" \
                "${HOME}/.config/containers/auth.json" > "${HOME}/.config/containers/auth.json.tmp" && \
                mv "${HOME}/.config/containers/auth.json.tmp" \
                  "${HOME}/.config/containers/auth.json" || \
                echo '{}' > "${HOME}/.config/containers/auth.json"
            else
              mkdir -p "${HOME}/.config/containers"
              echo '{}' > "${HOME}/.config/containers/auth.json"
            fi
            return 0
          fi

          # For other registries, use publishing credentials if available
          if [ -z "${PUBLISHING_CREDENTIAL}" ]; then
            echo "WARNING: No publishing credentials available for ${authName}" >&2
            echo '{}' > "${HOME}/.config/containers/auth.json"
            return 0
          fi

          # disabling debug to not leak the token
          set +x
          jq -n --arg authName "${authName}" \
                --arg token "$(base64 -w 0 < <(printf %s "${PUBLISHING_CREDENTIAL}"))" \
                '.auths[$authName].auth = $token' > "${HOME}/.config/containers/auth.json"
          set -x
        }

        # performs kerberos authentication.
        base64 -d /mnt/service-account-secret/keytab > "/tmp/keytab"

        KRB5_TEMP_CONF=$(mktemp)
        KRB5_PRINCIPAL=$(cat /mnt/service-account-secret/principal)

        echo "${KRB5_CONF_CONTENT}" > "${KRB5_TEMP_CONF}"
        export KRB5_CONFIG="${KRB5_TEMP_CONF}"
        export KRB5_TRACE=/dev/stderr

        retry 5 kinit -V "${KRB5_PRINCIPAL}" -k -t "/tmp/keytab"

        set -x

        FROM_INDEX="$(params.fromIndex)"

        # Validate that required environment variables are set
        if [ -z "${FBC_FRAGMENTS:-}" ]; then
            echo "Error: FBC_FRAGMENTS environment variable is required"
            exit 1
        fi
        if [ -z "${FROM_INDEX:-}" ]; then
            echo "Error: FROM_INDEX environment variable is required"
            exit 1
        fi

        # validate fbcFragments parameter is valid JSON array
        if ! echo "${FBC_FRAGMENTS}" | jq -e . >/dev/null 2>&1; then
          echo "Error: fbcFragments parameter must be a valid JSON array"
          jq -n '{ "state": "failed", "state_reason": "Invalid fbcFragments parameter" }' \
            | tee "$(results.buildState.path)"
          echo -n 1 > "$(results.exitCode.path)"
          exit 1
        fi

        # check if fbcFragments array is empty
        if [ "$(echo "${FBC_FRAGMENTS}" | jq 'length')" -eq 0 ]; then
          echo "Error: fbcFragments array is empty - no fragments to process"
          jq -n '{ "state": "failed", "state_reason": "Empty fbcFragments array" }' | tee "$(results.buildState.path)"
          echo -n 1 > "$(results.exitCode.path)"
          exit 1
        fi

        # Use pre-determined publishing decisions from prepare-fbc-parameters
        echo "Processing fragments: ${FBC_FRAGMENTS}"
        mustOverwriteFromIndexImage="$(params.mustOverwriteFromIndexImage)"
        mustPublishIndexImage="$(params.mustPublishIndexImage)"

        echo "Using pre-determined publishing decisions from prepare-fbc-parameters:"
        echo "             \`mustOverwriteFromIndexImage==${mustOverwriteFromIndexImage}\`"
        echo "             \`mustPublishIndexImage==${mustPublishIndexImage}\`"

        # Sort fragments once for consistent use throughout the script
        sorted_fbc_fragments=$(echo "${FBC_FRAGMENTS}" | jq 'sort')

        # if it finds a build which is completed or in progress, it should exit this step and jump to
        # the next step `s-wait-for-build-state` which will watch the build until it is completed.
        # Pass build_tags to enable PLR filtering for in-progress builds
        # shellcheck disable=SC2016 # Tekton substitutes params before bash runs; single quotes preserve JSON
        build_tags_param='$(params.buildTags)'
        build=$(check_previous_build "${KRB5_PRINCIPAL}" "${FROM_INDEX}" \
                  "${sorted_fbc_fragments}" "${build_tags_param}")
        if [ -n "${build}" ]; then
          echo "=== A previous build for this fragment was found ==="
          echo "${build}" | gzip -c | base64 -w0 | tee "$(results.jsonBuildInfo.path)"
          exit 0
        fi

        # adds the json request parameters to a file to be used as input data
        # for curl and preventing shell expansion.
        json_input="/tmp/$$.tmp"
        json_raw_input="/tmp/$$_raw.tmp"

        cat > "$json_raw_input" <<JSON
        {
          "fbc_fragments": ${sorted_fbc_fragments},
          "from_index": "${FROM_INDEX}",
          "build_tags": $(params.buildTags),
          "add_arches": $(params.addArches),
          "overwrite_from_index": ${mustOverwriteFromIndexImage},
          "overwrite_from_index_token": "${IIB_OVERWRITE_FROM_INDEX_USERNAME}:${IIB_OVERWRITE_FROM_INDEX_TOKEN}"
        }
        JSON

        # filtering out empty params
        jq -r '
          if .overwrite_from_index == false then del(( .overwrite_from_index, .overwrite_from_index_token)) else . end |
          if(.add_arches | length) == 0 then del(.add_arches) else . end |
          if(.build_tags | length) == 0 then del(.build_tags) else . end' "${json_raw_input}" > "${json_input}"

        jq -n '{ "state": "in_progress", "state_reason": "Calling IIB endpoint" }' | tee "$(results.buildState.path)"
        # adds image to the index.
        iib_response=$(curl -u : --negotiate -s -X POST \
          -H "Content-Type: application/json" -d@"${json_input}" --insecure \
          "${IIB_SERVICE_URL}/builds/fbc-operations")

        # checks if the previous call returned an error and exits if so
        if jq -e -r ".error | select( . != null )" <<< "${iib_response}" >/dev/null; then
            jq -n '{ "state": "failed", "state_reason": "IIB service error" }' | tee "$(results.buildState.path)"
            echo -n 1 > "$(results.exitCode.path)"
            exit 1
        fi

        # compress and store the response only after error check passes
        echo "${iib_response}" | gzip -c | base64 -w0 > "$(results.jsonBuildInfo.path)"
    - name: update-fbc-catalog-wait-for-iib-build-step
      image: >-
        quay.io/konflux-ci/release-service-utils@sha256:f10b4ad888634a7633f76ede29003ce1471aec2b76a7d9e01ad282a3011eb78f
      computeResources:
        limits:
          memory: 256Mi
        requests:
          memory: 256Mi
          cpu: 250m
      volumeMounts:
        - name: iib-services-config-vol
          mountPath: "/mnt/iib-services-config"
      script: |
        #!/usr/bin/env bash
        # shellcheck disable=SC2317 # shellcheck calls all the commands in the function unreachable
        IIB_SERVICE_URL="$(cat /mnt/iib-services-config/url)"

        # export the variable required by the watch_build_state function
        export IIB_SERVICE_URL
        set -x

        # shellcheck disable=SC2329 # function is used with timeout command
        watch_build_state() {
            build_id="$(base64 -d < "$(results.jsonBuildInfo.path)" | gunzip | jq -r ".id")"
            state=""
            poll_count=0
            start_time=$(date +%s)
            last_log_time=${start_time}

            echo "INFO: Monitoring IIB build ${build_id}"
            echo "INFO: IIB service URL: ${IIB_SERVICE_URL}"

            while true; do
                #
                # fetching build information.
                if ! build_info=$(curl -s "${IIB_SERVICE_URL}/builds/${build_id}") || [ -z "${build_info}" ]; then
                    echo "WARNING: Failed to fetch build info from IIB service"
                    sleep 30
                    continue
                fi

                # Check for errors in response
                if echo "${build_info}" | jq -e '.error' >/dev/null 2>&1; then
                    error_msg=$(echo "${build_info}" | jq -r '.error')
                    echo "ERROR: IIB service returned error: ${error_msg}"
                    sleep 30
                    continue
                fi

                # get state from the build information.
                state="$(jq -r ".state" <<< "${build_info}")"
                poll_count=$((poll_count + 1))
                current_time=$(date +%s)
                elapsed=$((current_time - start_time))

                # Log status every 5 minutes (10 polls at 30s intervals)
                if [ $((current_time - last_log_time)) -ge 300 ]; then
                    created_time=$(jq -r '.created // empty' <<< "${build_info}")
                    updated_time=$(jq -r '.updated // empty' <<< "${build_info}")
                    state_reason=$(jq -r '.state_reason // "none"' <<< "${build_info}")
                    echo "INFO: Build status check #${poll_count} (elapsed: ${elapsed}s):"
                    echo "  - State: ${state}"
                    echo "  - State reason: ${state_reason}"
                    echo "  - Created: ${created_time}"
                    echo "  - Last updated: ${updated_time}"
                    last_log_time=${current_time}
                fi

                # remove the history as it breaks the results build up
                jq -r 'del(.state_history)' <<< "${build_info}" | jq -c . | \
                  gzip -c | base64 -w0 > "$(results.jsonBuildInfo.path)"
                url="$(jq -r ".logs.url" <<< "${build_info}")"
                echo IIB log url is: "${url}" > "$(results.iibLog.path)"
                case ${state} in
                  "complete")
                    # Determine final index image based on release strategy
                    if [ "$(params.mustOverwriteFromIndexImage)" = "true" ] && \
                       [ "$(params.mustPublishIndexImage)" = "true" ]; then
                        # Production build: use IIB-generated index_image
                        final_index_image=$(jq -r ".index_image" <<< "${build_info}")
                        # If we overwrote the from index, verify the index_image matches the fromIndex from build data
                        expected_from_index=$(jq -r ".from_index" <<< "${build_info}")
                        if [ "${final_index_image}" != "${expected_from_index}" ]; then
                            echo "Error: Build completed but index_image '${final_index_image}' does not match" \
                              "expected fromIndex '${expected_from_index}'"
                            echo "This indicates that the from index was not properly overwritten"
                            error_msg="Index image mismatch: expected ${expected_from_index}, got ${final_index_image}."
                            jq -n --arg reason "${error_msg}" \
                              '{ "state": "failed", "state_reason": $reason }' > "$(results.buildState.path)"
                            return 1
                        fi
                    elif [ "$(params.mustOverwriteFromIndexImage)" = "false" ] && \
                         [ "$(params.mustPublishIndexImage)" = "true" ]; then
                        # Hotfix/preGA build: use IIB-generated index_image
                        final_index_image=$(jq -r ".index_image" <<< "${build_info}")
                    elif [ "$(params.mustOverwriteFromIndexImage)" = "false" ] && \
                         [ "$(params.mustPublishIndexImage)" = "false" ]; then
                        # Staging build: use IIB-generated index_image
                        final_index_image=$(jq -r ".index_image" <<< "${build_info}")
                    else
                        echo "Error: Invalid combination of mustOverwriteFromIndexImage=true" \
                             "and mustPublishIndexImage=false"
                        echo "This could be caused by multiple pipelines releasing to production running in parallel"
                        error_msg="Invalid release strategy combination."
                        jq -n --arg reason "${error_msg}" \
                          '{ "state": "failed", "state_reason": $reason }' > "$(results.buildState.path)"
                        return 1
                    fi
                    break ;;
                  "failed") break ;;
                  *) echo -en "."; sleep 30; continue ;;
                esac
            done
            echo
            base64 -d < "$(results.jsonBuildInfo.path)" | gunzip | \
              jq -cr '{ "state": .state, "state_reason": .state_reason }' \
            | tee "$(results.buildState.path)"
            test "${state}" = "complete" && exit 0 || exit 1
        }

        echo -en "waiting for build state to exit..."
        # adding timeout here due to the Task timeout not accepting $(params.buildTimeoutSeconds)
        # as parameter.
        export -f watch_build_state
        timeout "$(params.buildTimeoutSeconds)" bash -c watch_build_state
        BUILDEXIT=$?

        # it should continue only if the IIB build status is complete
        if [ ${BUILDEXIT} -eq 0 ]; then
            echo -n 0 > "$(results.exitCode.path)"

            # get the manifest digests
            indexImageCopy=$(base64 -d < "$(results.jsonBuildInfo.path)" | gunzip | \
              jq -cr .internal_index_image_copy)
            # Use this to obtain the manifest digests for each arch in manifest list
            indexImageDigestsRaw=$(skopeo inspect --retry-times 3 --raw "docker://${indexImageCopy}")
            # according the IIB team,
            #  "all index images will always be multi-arch with a manifest list"
            #
            indexImageDigests=$(echo "${indexImageDigestsRaw}" | \
               jq -r \
               '.manifests[]? | select(.mediaType=="application/vnd.docker.distribution.manifest.v2+json") | .digest' \
               | tr '\n' ' ' | sed 's/ $//')  # make sure the result is on one line and remove trailing space
            echo -n "${indexImageDigests}" > "$(results.indexImageDigests.path)"
            if [ -z "${indexImageDigests}" ] ; then
              echo "Index image produced is not multi-arch with a manifest list"
              echo -n 1 > "$(results.exitCode.path)"
            fi
        else
            if [ ${BUILDEXIT} -eq 124 ]; then
                echo "Timeout while waiting for the build to finish"
                jq -n '{ "state": "failed", "state_reason": "Build timeout" }' | tee "$(results.buildState.path)"
            else
                echo "Build failed with exit code ${BUILDEXIT}"
                jq -n --arg exit_code "$BUILDEXIT" \
                  '{ "state": "failed", "state_reason": ("Build failed with exit code " + $exit_code) }' \
                  | tee "$(results.buildState.path)"
            fi
            echo -n "" > "$(results.indexImageDigests.path)"
            echo -n "$BUILDEXIT" > "$(results.exitCode.path)"
        fi
        # We don't put the log in a result because tekton results are too limited for what we can put
        # to be useful, but still print it for debugging
        curl -s "$(awk '{print $NF}' < "$(results.iibLog.path)")"

        exit "${BUILDEXIT}"
