---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: filter-already-released-advisory-images
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    This task filters out images from a snapshot that have already been published
    in advisories. It is a **managed Tekton task** that triggers an **internal task**
    using an InternalRequest, and overwrites the mapped snapshot file with a
    filtered version containing only **unpublished images**.

    The task also outputs a `skip_release` result, which is set to `true`
    if all components are already released (and the pipeline can be skipped),
    or `false` otherwise.

    The task overwrites the original mapped snapshot file in place with a
    filtered version containing only unpublished images.
    Downstream tasks continue to use the same snapshot path.
  params:
    - name: snapshotPath
      type: string
      description: Path to the JSON string of the Snapshot spec in the data workspace
    - name: releasePlanAdmissionPath
      type: string
      description: Path to the JSON string of the ReleasePlanAdmission in the data workspace
    - name: resultsDirPath
      type: string
      description: Path to the results directory in the data workspace
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: Git revision to use for internal task
    - name: pipelineRunUid
      type: string
      description: UID of the current pipelineRun
    - name: synchronously
      type: string
      description: Whether to wait for the InternalRequest completion
      default: "true"
    - name: dataPath
      description: Path to the JSON string of the merged data to use in the data workspace
      type: string
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  results:
    - name: result
      description: Success or failure result
    - name: skip_release
      description: Whether to skip release tasks (true if all components are already released)
    - description: Produced trusted data artifact
      name: sourceDataArtifact
      type: string
    - name: environment
      type: string
      description: The environment for the advisory to be published. Options are stage and production
    - name: latest_advisory_url
      type: string
      description: URL of the latest matching advisory when all components are already released
    - name: latest_advisory_internal_url
      type: string
      description: Internal URL of the latest matching advisory when all components are already released
  volumes:
    - name: workdir
      emptyDir: {}
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
    securityContext:
      runAsUser: 1001
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: run-script
      image: quay.io/konflux-ci/release-service-utils@sha256:f10b4ad888634a7633f76ede29003ce1471aec2b76a7d9e01ad282a3011eb78f
      computeResources:
        limits:
          memory: 512Mi
        requests:
          memory: 512Mi
          cpu: 350m
      script: |
        #!/bin/bash
        set -x

        SNAPSHOT_FILE="$(params.dataDir)/$(params.snapshotPath)"
        if [ ! -f "$SNAPSHOT_FILE" ]; then
            echo "No valid snapshot file was provided at $SNAPSHOT_FILE"
            exit 1
        fi

        # Transform snapshot components to architecture-specific images
        echo "Transforming snapshot components using get-image-architectures..."
        SNAPSHOT_JSON=$(jq '.' "$SNAPSHOT_FILE")
        TRANSFORMED_COMPONENTS=$(mktemp)

        jq -c '.components[]' <<< "$SNAPSHOT_JSON" | while IFS= read -r component; do
            CONTAINER_IMAGE=$(jq -r '.containerImage' <<< "$component")
            COMPONENT_NAME=$(jq -r '.name' <<< "$component")

            echo "Processing component: $COMPONENT_NAME with image: $CONTAINER_IMAGE" >&2

            if ! digests=$(get-image-architectures "${CONTAINER_IMAGE}"); then
                echo "Warning: Failed to resolve architectures for ${CONTAINER_IMAGE}, skipping component" >&2
                continue
            fi

            repositories=$(jq -c '.repositories' <<< "$component")
            NUM_REPOS=$(jq 'length' <<< "$repositories")
            for ((i = 0; i < NUM_REPOS; i++)); do
                repo_url=$(jq -r --argjson i "$i" '.[$i]."rh-registry-repo"' <<< "$repositories")

                while IFS= read -r arch_json; do
                    if [[ -n "$arch_json" ]]; then
                        arch_digest=$(jq -r '.digest' <<< "$arch_json")
                        containerImage="${repo_url}@${arch_digest}"

                        # Create minimal object with only the 4 fields needed by the consuming task
                        jq -n \
                            --arg name "$COMPONENT_NAME" \
                            --arg ci "$containerImage" \
                            --argjson tags "$(jq '.tags' <<< "$component")" \
                            --arg repo "$repo_url" \
                            '{
                              name: $name,
                              containerImage: $ci,
                              tags: $tags,
                              repository: $repo
                            }'
                    fi
                done <<< "$digests"
            done
        done > "$TRANSFORMED_COMPONENTS"

        # Create transformed snapshot with arch-specific images
        transformedSnapshot=$(jq -sc '.' "$TRANSFORMED_COMPONENTS" | gzip -c | base64 -w 0)
        rm -f "$TRANSFORMED_COMPONENTS"

        if [ -z "$transformedSnapshot" ]; then
            echo "Failed to create transformed snapshot"
            exit 1
        fi

        echo "Transformation complete. Arch-specific images created."

        RPA_FILE="$(params.dataDir)/$(params.releasePlanAdmissionPath)"
        if [ ! -f "$RPA_FILE" ]; then
            echo "No valid ReleasePlanAdmission file was provided at $RPA_FILE"
            exit 1
        fi
        origin=$(jq -r '.spec.origin' "$RPA_FILE")
        if [ -z "$origin" ]; then
            echo "Failed to read origin from ReleasePlanAdmission"
            exit 1
        fi

        pipelinerun_label="internal-services.appstudio.openshift.io/pipelinerun-uid"

        # Determine advisory_secret_name based on repositories in snapshot
        pending_repositories=$(jq -r '.components[] |
          .repositories[]?.url |
          select(test("quay.io/redhat-pending/|quay.io/rh-flatpaks-stage/"))' "$SNAPSHOT_FILE")
        prod_repositories=$(jq -r '.components[] |
          .repositories[]?.url |
          select(test("quay.io/redhat-prod/|quay.io/rh-flatpaks-prod/"))' "$SNAPSHOT_FILE")
        orphan_repositories=$(jq -r '.components[] |
          .repositories[]?.url |
          select(. != null and . != "") |
          select(test("quay.io/redhat-prod/|quay.io/rh-flatpaks-prod/") | not) |
          select(test("quay.io/redhat-pending/|quay.io/rh-flatpaks-stage/") | not)' "$SNAPSHOT_FILE")
        foundPendingRepositories=false
        [ -n "${pending_repositories}" ] && foundPendingRepositories=true
        foundProdRepositories=false
        [ -n "${prod_repositories}" ] && foundProdRepositories=true
        foundOrphanRepositories=false
        [ -n "${orphan_repositories}" ] && foundOrphanRepositories=true

        echo "Repository status:"
        echo "- Pending repositories: ${foundPendingRepositories}"
        echo "- Production repositories: ${foundProdRepositories}"
        echo "- Orphan repositories: ${foundOrphanRepositories}"

        if [ "${foundPendingRepositories}" == "true" ] && [ "${foundProdRepositories}" == "true" ]; then
          echo "Error: cannot publish to both redhat-pending and redhat-prod repositories"
          exit 1
        fi

        if [ "${foundPendingRepositories}" == "false" ] && [ "${foundProdRepositories}" == "false" ]; then
          echo "Error: you must publish to either redhat-pending or redhat-prod repositories"
          exit 1
        fi

        if [ "${foundOrphanRepositories}" == "true" ]; then
          echo "Error: you must publish to either redhat-pending or redhat-prod repositories"
          exit 1
        fi

        # Select the correct secret name
        if [ "${foundPendingRepositories}" == "true" ]; then
          advisorySecretName="create-advisory-stage-secret"
          printf "stage" | tee "$(results.environment.path)"
        else
          advisorySecretName="create-advisory-prod-secret"
          printf "production" | tee "$(results.environment.path)"
        fi

        # Check if skipFilter is true in data.json
        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ -f "$DATA_FILE" ] && [ "$(jq -r '.skipFilter' "$DATA_FILE")" = "true" ]; then
          echo "skipFilter is true in data.json, skipping filtering and passing snapshot unchanged."
          echo -n "false" > "$(results.skip_release.path)"
          echo -n "Success" > "$(results.result.path)"
          # Output the original snapshot unchanged (no filtering)
          exit 0
        fi

        RESULTS_FILE="$(params.dataDir)/$(params.resultsDirPath)/filter-already-released-advisory-images-results.json"
        IR_FILE="$(params.dataDir)/$(context.task.name)/ir-result.txt"
        mkdir -p "$(dirname "$IR_FILE")"

        echo "Creating internal request for filtering already-released advisory images..."
        # Because of the tee, this will always succeed
        internal-request --pipeline "filter-already-released-advisory-images" \
                         -p transformedSnapshot="$transformedSnapshot" \
                         -p origin="$origin" \
                         -p advisory_secret_name="$advisorySecretName" \
                         -p internalRequestPipelineRunName="$(params.pipelineRunUid)" \
                         -p taskGitUrl="$(params.taskGitUrl)" \
                         -p taskGitRevision="$(params.taskGitRevision)" \
                         -s "$(params.synchronously)" \
                         -l ${pipelinerun_label}="$(params.pipelineRunUid)" \
                         | tee "$IR_FILE"

        internalRequest=$(awk -F"'" '/created/ { print $2 }' "$IR_FILE")
        echo "Internal request created: ${internalRequest}"

        echo "Internal request status:"
        kubectl get internalrequest "${internalRequest}" -o json | jq .

        results=$(kubectl get internalrequest "$internalRequest" -o=jsonpath='{.status.results}')
        if [ -z "$results" ]; then
          echo "No results found in internal request. Status:"
          kubectl get internalrequest "${internalRequest}" -o yaml
          exit 1
        fi

        internalRequestPipelineRunName="$(jq -jr '.internalRequestPipelineRunName // ""' <<< "${results}")"
        internalRequestTaskRunName="$(jq -jr '.internalRequestTaskRunName // ""' <<< "${results}")"
        latestAdvisoryUrl="$(jq -jr '.advisory_url // ""' <<< "${results}")"
        latestAdvisoryInternalUrl="$(jq -jr '.advisory_internal_url // ""' <<< "${results}")"
        echo "Internal request details:"
        echo "- Pipeline run: ${internalRequestPipelineRunName}"
        echo "- Task run: ${internalRequestTaskRunName}"
        echo "- Latest advisory URL: ${latestAdvisoryUrl}"
        echo "- Latest advisory internal URL: ${latestAdvisoryInternalUrl}"

        if [[ "$(jq -r '.result' <<< "$results")" == "Success" ]]; then
          echo "Image filtering successful"

          # Get the unreleased components list
          UNRELEASED_COMPONENTS_RAW=$(jq -r '.unreleased_components // ""' <<< "$results")
          if [ -z "$UNRELEASED_COMPONENTS_RAW" ]; then
            echo "No unreleased components list found in results. Results:"
            echo "$results"
            exit 1
          fi

          UNRELEASED_COMPONENTS=$(mktemp)
          FILTERED_SNAPSHOT=$(mktemp)

          echo "$UNRELEASED_COMPONENTS_RAW" | base64 -d | gunzip | tee "$UNRELEASED_COMPONENTS"

          # Filter the original snapshot using the unreleased components list
          jq --slurpfile unreleased "$UNRELEASED_COMPONENTS" '
            .components = (
              .components | map(
                select(
                  .name as $name | ($unreleased[0] | contains([$name]))
                )
              )
            )
          ' "$SNAPSHOT_FILE" > "$FILTERED_SNAPSHOT"

          # Check if the filtered snapshot has any components
          if jq -e '.components | length == 0' < "$FILTERED_SNAPSHOT"; then
            echo "All images in the snapshot have already been released in advisories. Stopping pipeline."
            cat "$FILTERED_SNAPSHOT" > "$SNAPSHOT_FILE"
            echo -n "Success" > "$(results.result.path)"
            echo -n "true" > "$(results.skip_release.path)"

            # Write the latest advisory URLs to results
            echo -n "$latestAdvisoryUrl" > "$(results.latest_advisory_url.path)"
            echo -n "$latestAdvisoryInternalUrl" > "$(results.latest_advisory_internal_url.path)"

            # Create results file with advisory information (same format as create-advisory)
            jq -n --arg url "$latestAdvisoryUrl" --arg internal_url "$latestAdvisoryInternalUrl" \
              '{"advisory": {"url": $url, "internal_url": $internal_url}}' | tee "$RESULTS_FILE"
            exit 0
          fi

          cat "$FILTERED_SNAPSHOT" > "$SNAPSHOT_FILE"
          echo -n "Success" > "$(results.result.path)"
          echo -n "false" > "$(results.skip_release.path)"

          # Set advisory URL results to empty when components need release
          echo -n "" > "$(results.latest_advisory_url.path)"
          echo -n "" > "$(results.latest_advisory_internal_url.path)"
        else
          echo "Filtering failed. Results:"
          echo "$results"
          exit 1
        fi
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: "$(params.taskGitUrl)"
          - name: revision
            value: "$(params.taskGitRevision)"
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
