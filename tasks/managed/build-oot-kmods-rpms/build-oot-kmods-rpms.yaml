---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: build-oot-kmods-rpms
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Task to build RPM packages containing signed out-of-tree kernel modules
  params:
    - name: signedKmodsPath
      type: string
      description: Path where the signed kernel modules are stored in the workspace
    - name: rpmOutputPath
      type: string
      description: Path where the built RPM packages will be stored
      default: "rpms"
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The git repository URL for task and StepAction resolution
      default: https://github.com/konflux-ci/release-service-catalog.git
    - name: taskGitRevision
      type: string
      description: The git revision for task and StepAction resolution
      default: main
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  results:
    - name: sourceDataArtifact
      type: string
      description: Produced trusted data artifact
  volumes:
    - name: workdir
      emptyDir: {}
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
    securityContext:
      runAsUser: 1001
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: build-rpm-packages
      image: quay.io/konflux-ci/release-service-utils@sha256:f10b4ad888634a7633f76ede29003ce1471aec2b76a7d9e01ad282a3011eb78f
      computeResources:
        limits:
          memory: 512Mi
        requests:
          memory: 512Mi
          cpu: 250m
      script: |
        #!/usr/bin/env bash
        set -euxo pipefail

        SIGNED_KMODS_PATH="$(params.dataDir)/$(params.signedKmodsPath)"
        RPM_OUTPUT_PATH="$(params.dataDir)/$(params.rpmOutputPath)"

        echo "Building RPM packages from signed modules in: ${SIGNED_KMODS_PATH}"
        echo "RPM output path: ${RPM_OUTPUT_PATH}"

        # Check if this is a multi-architecture build
        if [ -f "$(params.dataDir)/arch_count.txt" ]; then
            arch_count=$(cat "$(params.dataDir)/arch_count.txt")
            echo "Processing $arch_count architecture(s) for RPM building"
        else
            echo "No architecture information found, assuming single architecture"
            arch_count=1
        fi

        # Create RPM output directory
        mkdir -p "${RPM_OUTPUT_PATH}"

        # Function to build RPM for a specific architecture
        build_rpm_for_arch() {
            local arch_name="$1"
            local source_dir="$2"

            echo "Building RPM for architecture: $arch_name"

            # Create architecture-specific work directory
            local arch_work_dir="${RPM_OUTPUT_PATH}/temp_build_${arch_name}"
            mkdir -p "$arch_work_dir"
            cd "$arch_work_dir"

            # Validate required files exist for this architecture
            if [ ! -f "$source_dir/envfile" ]; then
                echo "ERROR: envfile not found in $source_dir for architecture $arch_name"
                return 1
            fi

            if ! find "$source_dir" -name "*.ko" -type f | head -1 >/dev/null 2>&1; then
                echo "ERROR: No .ko files found in $source_dir for architecture $arch_name"
                return 1
            fi

            # Verify checksums specific to this architecture
            local checksum_file=""
            if [ "$arch_count" -gt 1 ]; then
                checksum_file="$source_dir/signed_kmods_checksums_${arch_name}.txt"
            else
                checksum_file="$source_dir/signed_kmods_checksums.txt"
            fi

            if [ ! -f "$checksum_file" ]; then
                echo "ERROR: checksum file not found: $checksum_file"
                echo "This file should be generated by the sign-oot-kmods task"
                return 1
            fi

            echo "Verifying .ko file checksums before RPM build for $arch_name..."
            cd "$source_dir"
            if ! sha256sum -c "$(basename "$checksum_file")"; then
                echo "ERROR: Checksum verification failed for .ko files in $arch_name"
                echo "The .ko files have been modified since signing"
                return 1
            fi
            echo "Checksum verification passed for $arch_name - .ko files are intact"
            cd "$arch_work_dir"

            # Copy signed kmods, envfile, and checksums to working directory
            cp "$source_dir"/*.ko .
            cp "$source_dir/envfile" .
            cp "$checksum_file" ./signed_kmods_checksums.txt

            # Continue with existing RPM build logic for this architecture
            # shellcheck source=/dev/null
            . ./envfile

            # Validate required environment variables
            if [ -z "${DRIVER_VENDOR:-}" ] || [ -z "${DRIVER_VERSION:-}" ] || [ -z "${KERNEL_VERSION:-}" ]; then
                echo "ERROR: Missing required environment variables from envfile for $arch_name"
                return 1
            fi

            echo "Building RPM for $arch_name with DRIVER_VENDOR=$DRIVER_VENDOR,"
            echo "  DRIVER_VERSION=$DRIVER_VERSION, KERNEL_VERSION=$KERNEL_VERSION"

            # Create architecture-specific RPM output directory
            local arch_rpm_dir="${RPM_OUTPUT_PATH}"
            if [ "$arch_count" -gt 1 ]; then
                arch_rpm_dir="${RPM_OUTPUT_PATH}/${arch_name}"
            fi
            mkdir -p "$arch_rpm_dir"

            # Set up RPM build environment for this architecture
            export RPM_BUILD_ROOT="${arch_work_dir}/rpmbuild"
            mkdir -p "${RPM_BUILD_ROOT}"/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}

            # Package information - include arch in name for multiarch builds
            if [ "$arch_count" -gt 1 ]; then
                # For multiarch builds, include architecture in package name for clarity
                PACKAGE_NAME="${DRIVER_VENDOR}-kmods-${arch_name}"
            else
                # For single arch builds, use standard name
                PACKAGE_NAME="${DRIVER_VENDOR}-kmods"
            fi
            PACKAGE_VERSION="${DRIVER_VERSION}"
            # Strip architecture from kernel version to avoid duplication in RPM name
            KERNEL_VERSION_NO_ARCH="${KERNEL_VERSION%.x86_64}"
            KERNEL_VERSION_NO_ARCH="${KERNEL_VERSION_NO_ARCH%.aarch64}"
            PACKAGE_RELEASE="1.$(echo "${KERNEL_VERSION_NO_ARCH}" | tr '.-' '_')"
            SPEC_FILE="${RPM_BUILD_ROOT}/SPECS/${PACKAGE_NAME}.spec"

            # Determine target architecture based on arch_name or kernel version
            local target_arch
            if [ "$arch_count" -gt 1 ]; then
                # Multi-arch build: use arch name mapping
                case "$arch_name" in
                    amd64) target_arch="x86_64" ;;
                    arm64) target_arch="aarch64" ;;
                    x86_64) target_arch="x86_64" ;;
                    *) target_arch="x86_64" ;; # fallback
                esac
            else
                # Single arch build: detect from kernel version
                if [[ "${KERNEL_VERSION}" == *.x86_64 ]]; then
                    target_arch="x86_64"
                elif [[ "${KERNEL_VERSION}" == *.aarch64 ]]; then
                    target_arch="aarch64"
                else
                    target_arch="x86_64"  # fallback to x86_64
                fi
            fi

            # For kernel modules, use the target architecture
            local rpm_arch="$target_arch"

            echo "Using RPM BuildArch: $rpm_arch for architecture: $arch_name (kernel modules are pre-built)"

            # Check for custom spec file at repository root
            CUSTOM_SPEC_FILE="$(params.dataDir)/${PACKAGE_NAME}.spec"
            if [ -f "${CUSTOM_SPEC_FILE}" ]; then
                echo "Using custom spec file for $arch_name: ${CUSTOM_SPEC_FILE}"
                cp "${CUSTOM_SPEC_FILE}" "${SPEC_FILE}"
            else
                echo "Creating RPM spec file for $arch_name: ${SPEC_FILE}"

                # Create RPM spec file using RPM macros
                {
                  echo "Name:           %{package_name}"
                  echo "Version:        %{package_version}"
                  echo "Release:        %{package_release}"
                  echo "Summary:        %{driver_vendor} out-of-tree kernel modules for kernel %{kernel_version}"
                  echo "License:        Proprietary"
                  echo "Group:          System Environment/Kernel"
                  echo "BuildArch:      %{rpm_arch}"
                  echo "Requires:       kernel = %{kernel_version}"
                  # Prevent rpmbuild from stripping or modifying already-signed .ko files
                  echo "%undefine _debugsource_packages"
                  echo "%undefine _debuginfo_subpackages"
                  echo "%undefine debug_package"
                  echo "%global __brp_strip /bin/true"
                  echo "%global __brp_strip_comment_note /bin/true"
                  echo "%global __brp_strip_static_archive /bin/true"
                  echo "%global __os_install_post %{nil}"
                  echo ""
                  echo "%description"
                  echo "This package contains signed out-of-tree kernel modules for %{driver_vendor}"
                  echo "driver version %{package_version}, built for kernel %{kernel_version}."
                  echo ""
                  echo "%prep"
                  echo "# No prep needed"
                  echo ""
                  echo "%build"
                  echo "# No build needed"
                  echo ""
                  echo "%install"
                  echo "mkdir -p %{buildroot}/lib/modules/%{kernel_version}/extra/%{driver_vendor}"
                  echo "cp %{_sourcedir}/*.ko %{buildroot}/lib/modules/%{kernel_version}/extra/%{driver_vendor}/"
                  echo ""
                  echo "%files"
                  echo "/lib/modules/%{kernel_version}/extra/%{driver_vendor}/*.ko"
                  echo ""
                  echo "%post"
                  echo "/sbin/depmod -a %{kernel_version} || :"
                  echo ""
                  echo "%postun"
                  echo "/sbin/depmod -a %{kernel_version} || :"
                  echo ""
                  echo "%changelog"
                  echo "* $(date '+%a %b %d %Y') Konflux CI <konflux-ci@redhat.com> -" \
                       "%{package_version}-%{package_release}"
                  echo "- Automated build of signed %{driver_vendor} kernel modules for" \
                       "%{kernel_version}"
                } > "${SPEC_FILE}"
            fi

            # Copy signed .ko files to SOURCES directory
            echo "Copying signed .ko files to RPM SOURCES for $arch_name..."
            cp ./*.ko "${RPM_BUILD_ROOT}/SOURCES/"

            echo "Files in SOURCES directory for $arch_name:"
            find "${RPM_BUILD_ROOT}/SOURCES" -name "*.ko" -exec ls -la {} \;

            # Verify checksums again in RPM SOURCES directory
            echo "Verifying .ko files in RPM SOURCES directory for $arch_name..."
            cd "${RPM_BUILD_ROOT}/SOURCES"
            if ! sha256sum -c "${arch_work_dir}/signed_kmods_checksums.txt"; then
                echo "ERROR: Checksum verification failed for .ko files in RPM SOURCES for $arch_name"
                echo "Files may have been corrupted during copy operation"
                return 1
            fi
            echo "RPM SOURCES checksum verification passed for $arch_name"
            cd "$arch_work_dir"

            # Build the RPM
            echo "Building RPM package for $arch_name..."
            rpmbuild --target "${target_arch}" \
                     --define "_topdir ${RPM_BUILD_ROOT}" \
                     --define "_sourcedir ${RPM_BUILD_ROOT}/SOURCES" \
                     --define "package_name ${PACKAGE_NAME}" \
                     --define "package_version ${PACKAGE_VERSION}" \
                     --define "package_release ${PACKAGE_RELEASE}" \
                     --define "kernel_version ${KERNEL_VERSION}" \
                     --define "driver_vendor ${DRIVER_VENDOR}" \
                     --define "rpm_arch ${rpm_arch}" \
                     -bb "${SPEC_FILE}"

            # Move built RPMs to architecture-specific output directory
            find "${RPM_BUILD_ROOT}/RPMS" -name "*.rpm" -exec mv {} "$arch_rpm_dir/" \;

            # Verify the built RPM
            RPM_FILE=$(find "$arch_rpm_dir" -name "*.rpm" | head -1)
            if [ -n "${RPM_FILE}" ]; then
                echo "Successfully created RPM for $arch_name: $(basename "$RPM_FILE")"

                # Verify that .ko files in the built RPM are signed
                echo "Verifying that .ko files in built RPM are signed for $arch_name..."
                VERIFICATION_DIR="$arch_work_dir/rpm_verification"
                mkdir -p "${VERIFICATION_DIR}"
                cd "${VERIFICATION_DIR}"

                # Extract .ko files from RPM
                rpm2cpio "${RPM_FILE}" | cpio -idm "*/lib/modules/*/*.ko" 2>/dev/null || true

                # Verify extracted .ko files match signed versions
                if find . -name "*.ko" -type f | head -1 >/dev/null; then
                    echo "Verifying checksums of .ko files extracted from RPM for $arch_name..."
                    find . -name "*.ko" -type f | while read -r ko_file; do
                        ko_basename=$(basename "${ko_file}")
                        if [ ! -f "$source_dir/${ko_basename}" ]; then
                            echo "ERROR: ${ko_basename} not found in signed kmods directory for $arch_name"
                            exit 1
                        fi

                        EXTRACTED_CHECKSUM=$(sha256sum "${ko_file}" | cut -d' ' -f1)
                        SIGNED_CHECKSUM=$(sha256sum "$source_dir/${ko_basename}" | cut -d' ' -f1)

                        if [ "${EXTRACTED_CHECKSUM}" != "${SIGNED_CHECKSUM}" ]; then
                            echo "ERROR: ${ko_basename} checksum mismatch for $arch_name"
                            echo "  RPM contains unsigned version!"
                            echo "  Extracted: ${EXTRACTED_CHECKSUM}"
                            echo "  Signed:    ${SIGNED_CHECKSUM}"
                            exit 1
                        fi
                        echo "SUCCESS: ${ko_basename} checksum matches signed version for $arch_name"
                    done
                    echo "SUCCESS: All .ko files in RPM match signed versions for $arch_name"
                else
                    echo "ERROR: No .ko files found in built RPM for $arch_name"
                    return 1
                fi

                cd "$arch_work_dir"
                rm -rf "${VERIFICATION_DIR}"
            else
                echo "ERROR: No RPM file created for $arch_name"
                return 1
            fi

            # Cleanup intermediate files for this architecture
            rm -rf "${RPM_BUILD_ROOT}"

            echo "RPM package created for $arch_name: $arch_rpm_dir/$(basename "$RPM_FILE")"
            return 0
        }

        # Process architectures for RPM building
        if [ "$arch_count" -gt 1 ]; then
            echo "Multi-architecture build detected, building RPMs for each architecture"

            # Process each architecture directory
            for arch_dir in "${SIGNED_KMODS_PATH}"/*/; do
                if [ -d "$arch_dir" ]; then
                    arch_name=$(basename "$arch_dir")
                    echo "Processing RPM build for architecture: $arch_name"

                    if build_rpm_for_arch "$arch_name" "$arch_dir"; then
                        echo "Successfully built RPM for $arch_name"
                    else
                        echo "ERROR: Failed to build RPM for $arch_name"
                        exit 1
                    fi
                fi
            done

            echo "Multi-architecture RPM building completed"

        else
            echo "Single architecture build, using standard RPM build"

            if build_rpm_for_arch "single" "${SIGNED_KMODS_PATH}"; then
                echo "Successfully built RPM for single architecture"
            else
                echo "ERROR: Failed to build RPM for single architecture"
                exit 1
            fi
        fi

        echo "RPM building complete for $arch_count architecture(s)."

        # List all built RPMs
        echo "Built RPM packages:"
        find "${RPM_OUTPUT_PATH}" -name "*.rpm" -o -name "*.tar.gz" | sort

        echo "RPM build completed successfully"
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
