---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: push-rpms-to-pulp
spec:
  description: |
    A task to push rpm packages from an OCI artifact to a Pulp repository.
  params:
    - name: SNAPSHOT_PATH
      type: string
      description: Path to the snapshot spec file containing image information
    - name: PULP_DOMAIN
      type: string
      description: The domain to use for Pulp operations
    - name: PULP_SECRET_NAME
      type: string
      description: >-
        The name of the secret containing the Pulp cli.toml file. It must have the cli.toml key
    - name: DEFAULT_EXCLUDES
      type: string
      description: comma-delimited list of file patterns to exclude from the upload
      default: "-debuginfo-, -debugsource-"
    - name: DEFAULT_ARCHITECTURES
      type: string
      description: >-
        Comma-delimited list of default architectures to use for noarch RPMs when
        no arch-specific RPMs are found
      default: "x86_64,aarch64,s390x,ppc64le"
    - name: resultsDirPath
      description: Path to the results directory in the data workspace
      type: string
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  results:
    - description: Produced trusted data artifact
      name: sourceDataArtifact
      type: string
  volumes:
    - name: workdir
      emptyDir: {}
    - name: pulp-secret-name-vol
      secret:
        secretName: $(params.PULP_SECRET_NAME)
        defaultMode: 0444
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true

  stepTemplate:
    env:
      - name: SNAPSHOT_PATH
        value: $(params.dataDir)/$(params.SNAPSHOT_PATH)
      - name: DEFAULT_EXCLUDES
        value: $(params.DEFAULT_EXCLUDES)
      - name: DEFAULT_ARCHITECTURES
        value: $(params.DEFAULT_ARCHITECTURES)
      - name: DATA_DIR
        value: $(params.dataDir)
      - name: PULP_DOMAIN
        value: $(params.PULP_DOMAIN)
      - name: PULP_SECRET_NAME
        value: $(params.PULP_SECRET_NAME)
      - name: RESULTS_DIR_PATH
        value: $(params.resultsDirPath)
      - name: ociStorage
        value: $(params.ociStorage)
      - name: ociArtifactExpiresAfter
        value: $(params.ociArtifactExpiresAfter)
      - name: trustedArtifactsDebug
        value: $(params.trustedArtifactsDebug)
      - name: IMAGES_TXT
        value: $(params.dataDir)/images.txt
      - name: FILES_DIR
        value: $(params.dataDir)/files
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: ORAS_OPTIONS
        value: $(params.orasOptions)
      - name: DEBUG
        value: $(params.trustedArtifactsDebug)
    volumeMounts:
      - name: workdir
        mountPath: "/var/workdir"
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
    workingDir: "/var/workdir"
    securityContext:
      runAsUser: 1001
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: push-rpms-to-pulp
      image: quay.io/konflux-ci/release-service-utils@sha256:304058ae848ca6311b53b505e80533fc337e9c1a46dedd4071ee436b14e476d9
      computeResources:
        limits:
          memory: 256Mi
        requests:
          memory: 256Mi
          cpu: 250m
      volumeMounts:
        - name: pulp-secret-name-vol
          mountPath: "/etc/secrets"
      script: |
        #!/bin/bash
        set -euo pipefail

        CONFIG_FILE_CONTENT="$(cat /etc/secrets/cli.toml)"

        set +x
        echo "${CONFIG_FILE_CONTENT:?}" > "/tmp/cli.toml"
        export PULP_CONFIG_FILE="/tmp/cli.toml"

        # Extract OAuth2 credentials from cli.toml
        PULP_BASE_URL=$(grep -E "^base_url\s*=" "$PULP_CONFIG_FILE" | sed 's/.*=\s*"\(.*\)"/\1/' | sed 's:/*$::')
        CLIENT_ID=$(grep -E "^client_id\s*=" "$PULP_CONFIG_FILE" | sed 's/.*=\s*"\(.*\)"/\1/')
        CLIENT_SECRET=$(grep -E "^client_secret\s*=" "$PULP_CONFIG_FILE" | sed 's/.*=\s*"\(.*\)"/\1/')
        TOKEN_URL="https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token"

        # Function to get OAuth2 access token
        
        get_access_token() {
          local token
          token=$(curl --retry 3 -s -X POST "$TOKEN_URL" \
            -u "${CLIENT_ID}:${CLIENT_SECRET}" \
            -d "grant_type=client_credentials" \
            -d "scope=api.console" | jq -r '.access_token')
          
          if [[ -z "$token" || "$token" == "null" ]]; then
            echo "Error: Failed to get OAuth2 access token" >&2
            return 1
          fi
          echo "$token"
        }

        # Function to add content to a repository via API
        add_content_to_repo() {
          local repo_name="$1"
          local hrefs_json="$2"
          local domain="${PULP_DOMAIN}"
          
          # Disable command echoing for sensitive operations
          set +x
          local access_token
          access_token=$(get_access_token) || return 1
          
          # Get repository href
          local repo_href
          repo_href=$(curl --retry 3 -s -H "Authorization: Bearer $access_token" \
            "${PULP_BASE_URL}/api/pulp/${domain}/api/v3/repositories/rpm/rpm/?name=${repo_name}" \
            | jq -r '.results[0].pulp_href')
          set -x
          
          if [[ -z "$repo_href" || "$repo_href" == "null" ]]; then
            echo "Error: Could not find repository href for ${repo_name}"
            return 1
          fi
          
          # Convert hrefs format: [{"pulp_href": "..."}] -> ["..."]
          local add_content_units
          add_content_units=$(echo "$hrefs_json" | jq '[.[].pulp_href]')
          
          # Add content to repository
          echo "Calling API: POST ${PULP_BASE_URL}${repo_href}modify/"
          set +x
          curl --retry 3 -s -X POST "${PULP_BASE_URL}${repo_href}modify/" \
            -H "Authorization: Bearer $access_token" \
            -H "Content-Type: application/json" \
            -d "{\"add_content_units\": $add_content_units}"
          set -x
        }

        set -x

        DOMAIN_EXISTS=$(pulp --config "$PULP_CONFIG_FILE" domain show --name "${PULP_DOMAIN}" \
          | jq -r ".name // \"\"" || echo "")
        if [[ "$DOMAIN_EXISTS" == "$PULP_DOMAIN" ]]; then
            echo "Domain '${PULP_DOMAIN}' exists"
        else
            echo "Domain '${PULP_DOMAIN}' not found."
            exit 1
        fi

        RESULTS_FILE="${DATA_DIR}/${RESULTS_DIR_PATH}/push-rpms-to-pulp-results.json"
        mkdir -p "$(dirname "${RESULTS_FILE}")"

        # Initialize results file with empty rpmfiles array
        echo '{"rpmfiles": []}' > "$RESULTS_FILE"

        jq -r '.components[].containerImage' "${SNAPSHOT_PATH}" | tee "${IMAGES_TXT}"

        AUTHFILE='/tmp/auth.json'
        mkdir -p "${FILES_DIR}"
        while read -r IMAGE; do
          echo "Processing ${IMAGE}"
          select-oci-auth "${IMAGE}" > "${AUTHFILE}"
          oras pull --registry-config "${AUTHFILE}" "${IMAGE}" -o "${FILES_DIR}"
        done < "${IMAGES_TXT}"

        cd "${FILES_DIR}"

        # Create filtered list of files to upload
        FILES_TO_UPLOAD=()

        # Convert comma-delimited exclude patterns to array
        IFS=',' read -ra EXCLUDE_PATTERNS <<< "${DEFAULT_EXCLUDES}"

        # Get all files and filter out excluded patterns
        for file in *; do
          if [ -f "$file" ]; then
            # Only process .rpm files
            if [[ "$file" != *.rpm ]]; then
              echo "Skipping $file (not an RPM file)"
              continue
            fi

            should_exclude=false

            # Check if file matches any exclude pattern
            for pattern in "${EXCLUDE_PATTERNS[@]}"; do
              # Remove leading/trailing whitespace from pattern
              pattern=$(echo "$pattern" | xargs)
              if [[ "$file" == *"$pattern"* ]]; then
                echo "Excluding $file (matches pattern: $pattern)"
                should_exclude=true
                break
              fi
            done

            # Add to upload list if not excluded
            if [ "$should_exclude" = false ]; then
              FILES_TO_UPLOAD+=("$file")
              echo "Including $file for upload"
            fi
          fi
        done

        # Extract architectures from RPM filenames
        ARCHES=()
        for file in "${FILES_TO_UPLOAD[@]}"; do
          # Skip .src.rpm and .noarch.rpm files
          if [[ "$file" == *.src.rpm ]] || [[ "$file" == *.noarch.rpm ]]; then
            continue
          fi

          # Extract architecture from filename (e.g., package-1.0-1.x86_64.rpm -> x86_64)
          if [[ "$file" =~ \.([^.]+)\.rpm$ ]]; then
            arch="${BASH_REMATCH[1]}"

            # Add to ARCHES array if not already present
            if [[ ! " ${ARCHES[*]} " == *" ${arch} "* ]]; then
              ARCHES+=("$arch")
              echo "Found architecture: $arch"
            fi
          fi
        done

        echo "Detected architectures: ${ARCHES[*]}"

        # Check if we have any noarch RPMs that need to be uploaded
        noarch_rpms=()
        for file in "${FILES_TO_UPLOAD[@]}"; do
          if [[ "$file" == *.noarch.rpm ]]; then
            noarch_rpms+=("$file")
          fi
        done

        # If we have noarch RPMs but no architectures, use default architectures from parameter
        if [ ${#noarch_rpms[@]} -gt 0 ] && [ ${#ARCHES[@]} -eq 0 ]; then
          echo "⚠️  Found noarch RPMs but no architecture-specific RPMs."
          echo "   Using default architectures from parameter: ${DEFAULT_ARCHITECTURES}"
          echo "   Available noarch RPMs: ${noarch_rpms[*]}"

          # Parse comma-delimited default architectures into array
          IFS=',' read -ra DEFAULT_ARCHES <<< "${DEFAULT_ARCHITECTURES}"
          for i in "${!DEFAULT_ARCHES[@]}"; do
            DEFAULT_ARCHES[i]=$(echo "${DEFAULT_ARCHES[i]}" | xargs)
          done
          ARCHES=("${DEFAULT_ARCHES[@]}")
        fi

        # Map to the specific arch: *.x86_64.rpm -> x86_64 repo
        # Map noarch rpm: *.noarch.rpm -> every arch repo
        # Map source rpms: *.src.rpm -> source rpm repo

        # Upload files organized by architecture
        for arch in "${ARCHES[@]}"; do
          echo "Processing architecture: $arch"

          REPO_EXISTS=$(pulp  --config "$PULP_CONFIG_FILE" --domain "${PULP_DOMAIN}" \
            rpm repository list --field name | jq -r ".[] | \
            select(.name == \"${arch}\") | .name")

          if [[ "$REPO_EXISTS" == "${arch}" ]]; then
              echo "Repository '${arch}' exists"
          else
              echo "Repository '${arch}' does not exist."
              exit 1
          fi

          # Collect hrefs for bulk add
          HREFS_JSON="[]"

          # Process arch-specific RPMs
          for pkg in "${FILES_TO_UPLOAD[@]}"; do
            if [[ "$pkg" == *."$arch".rpm ]]; then
              echo "Uploading $pkg to $arch repository..."
              set +e
              upload_response=$(pulp --config "$PULP_CONFIG_FILE" --domain "${PULP_DOMAIN}" rpm content upload \
                --file "${pkg}" --relative-path "$(basename "${pkg}")")
              set -e
              href=$(jq -r '.pulp_href' <<< "$upload_response")
              if [[ -z "$href" || "$href" == "null" ]]; then
                echo "Error: Failed to get pulp_href for $pkg. Upload response: $upload_response"
                exit 1
              fi
              echo "Uploaded $pkg -> $href"

              # Add href to collection
              HREFS_JSON=$(jq --arg href "$href" '. += [{"pulp_href": $href}]' <<< "$HREFS_JSON")

              jq --arg pkg "${pkg}" --arg arch "${arch}" --arg pulprepo "${PULP_DOMAIN}/${arch}" \
                '.rpmfiles += [{rpm: $pkg, arch: $arch, pulprepo: $pulprepo}]' \
                "$RESULTS_FILE" > tmp.json && mv tmp.json "$RESULTS_FILE"
            fi
            # Upload .noarch.rpm files to this arch repository
            if [[ "$pkg" == *.noarch.rpm ]]; then
              echo "Uploading noarch $pkg to $arch repository..."
              set +e
              upload_response=$(pulp --config "$PULP_CONFIG_FILE" --domain "${PULP_DOMAIN}" rpm content upload \
                --file "${pkg}" --relative-path "$(basename "${pkg}")")
              set -e
              href=$(jq -r '.pulp_href' <<< "$upload_response")
              if [[ -z "$href" || "$href" == "null" ]]; then
                echo "Error: Failed to get pulp_href for $pkg. Upload response: $upload_response"
                exit 1
              fi
              echo "Uploaded $pkg -> $href"

              # Add href to collection
              HREFS_JSON=$(jq --arg href "$href" '. += [{"pulp_href": $href}]' <<< "$HREFS_JSON")

              jq --arg pkg "${pkg}" --arg arch "noarch" --arg pulprepo "${PULP_DOMAIN}/${arch}" \
                '.rpmfiles += [{rpm: $pkg, arch: $arch, pulprepo: $pulprepo}]' \
                "$RESULTS_FILE" > tmp.json && mv tmp.json "$RESULTS_FILE"
            fi
          done

          # Bulk add all collected hrefs to repository via API
          if [[ $(jq 'length' <<< "$HREFS_JSON") -gt 0 ]]; then
            echo "Adding $(jq 'length' <<< "$HREFS_JSON") packages to $arch repository..."
            add_content_to_repo "$arch" "$HREFS_JSON"
          fi
        done

        # Upload and add .src.rpm files to source repository
        SRC_HREFS_JSON="[]"
        for pkg in "${FILES_TO_UPLOAD[@]}"; do
          if [[ "$pkg" == *.src.rpm ]]; then
            echo "Uploading $pkg (arch: source)..."
            set +e
            upload_response=$(pulp --config "$PULP_CONFIG_FILE" --domain "${PULP_DOMAIN}" rpm content upload \
              --file "${pkg}" --relative-path "$(basename "${pkg}")")
            set -e
            href=$(jq -r '.pulp_href' <<< "$upload_response")
            if [[ -z "$href" || "$href" == "null" ]]; then
              echo "Error: Failed to get pulp_href for $pkg. Upload response: $upload_response"
              exit 1
            fi
            echo "Uploaded $pkg -> $href"

            # Add href to collection
            SRC_HREFS_JSON=$(jq --arg href "$href" '. += [{"pulp_href": $href}]' <<< "$SRC_HREFS_JSON")

            jq --arg pkg "${pkg}" --arg arch "source" --arg pulprepo "${PULP_DOMAIN}/source" \
              '.rpmfiles += [{rpm: $pkg, arch: $arch, pulprepo: $pulprepo}]' \
              "$RESULTS_FILE" > tmp.json && mv tmp.json "$RESULTS_FILE"
          fi
        done

        # Bulk add all source rpms to source repository via API
        if [[ $(jq 'length' <<< "$SRC_HREFS_JSON") -gt 0 ]]; then
          echo "Adding $(jq 'length' <<< "$SRC_HREFS_JSON") source packages to source repository..."
          add_content_to_repo "source" "$SRC_HREFS_JSON"
        fi

        echo "Results written to: $RESULTS_FILE"
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: "$(params.taskGitUrl)"
          - name: revision
            value: "$(params.taskGitRevision)"
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
