---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: update-cr-status
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    A tekton task that updates the passed CR status with the contents stored in the files in the resultsDir.
  params:
    - name: resourceType
      description: The type of resource that is being patched
      type: string
      default: release
    - name: statusKey
      description: The top level key to overwrite in the resource status
      type: string
      default: artifacts
    - name: resource
      description: The namespaced name of the resource to be patched
      type: string
    - name: resultsDirPath
      description: |
        Path to the directory containing the result files in the data workspace which will be added to the
        resource's status
      type: string
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: resultArtifacts
      type: array
      description: Array of artifacts to use to obtain results
      default: []
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
  volumes:
    - name: workdir
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
  steps:
    - name: use-trusted-artifact-array
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 20m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact-array/use-trusted-artifact-array.yaml
      params:
        - name: sourceDataArtifacts
          value: $(params.resultArtifacts)
    - name: update-cr-status
      image: quay.io/konflux-ci/release-service-utils:02a8ddcd16113371a255fd1ef0a196399d300162
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 50m
      script: |
        #!/usr/bin/env bash
        set -ex

        RESULTS_DIR="$(params.dataDir)/$(params.resultsDirPath)"
        TEMP_FILE="/tmp/temp.json"
        RESULTS_JSON="/tmp/results.json"
        echo '{}' > "$RESULTS_JSON"

        for resultsFile in $([ -d "$RESULTS_DIR" ] && find "$RESULTS_DIR" -type f); do
            if ! jq . >/dev/null 2>&1 "${resultsFile}" ; then
                echo "Passed results JSON file ${resultsFile} in results directory was not proper JSON."
                exit 1
            fi
            
            # Merge with array concatenation for array fields and object merging
            jq --slurpfile new "${resultsFile}" '
              # Store current values as $base and get all unique keys from both objects
              . as $base | ($base | keys + ($new[0] | keys)) | unique | 
              # Process each key and build the merged result
              reduce .[] as $key ({}; . + {($key): (
                # Case 1: Both values are arrays - concatenate them
                if ($new[0][$key] | type == "array") and ($base[$key] | type == "array")
                then $base[$key] + $new[0][$key]
                else 
                  # Case 2: Both values are objects - merge them recursively
                  if ($new[0][$key] | type == "object") and ($base[$key] | type == "object")
                  then $base[$key] * $new[0][$key]
                  # Case 3: Default - use new value or fall back to base value
                  else $new[0][$key] // $base[$key]
                  end
                end
              )})
            ' "$RESULTS_JSON" > "$TEMP_FILE"
            mv "$TEMP_FILE" "$RESULTS_JSON"
        done

        IFS='/' read -r namespace name <<< "$(params.resource)"

        # Read the final JSON from the file
        FINAL_JSON=$(cat "$RESULTS_JSON")

        # Create patch file to avoid "Argument list too long" error
        PATCH_FILE="/tmp/patch-$(date +%s).json"
        echo "status: {'$(params.statusKey)':${FINAL_JSON}}" > "$PATCH_FILE"

        kubectl --warnings-as-errors=true patch "$(params.resourceType)" -n "$namespace" "$name" \
          --type=merge --subresource status --patch-file "$PATCH_FILE"

        # Clean up
        rm -f "$PATCH_FILE"
