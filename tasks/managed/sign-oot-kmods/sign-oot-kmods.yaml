---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: sign-oot-kmods
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Task to sign out-of-tree kernel modules using the internal signing server
  params:
    - name: dataPath
      type: string
      description: Path to the data JSON in the data workspace
    - name: signedKmodsPath
      type: string
      description: Path where the kernel modules are stored in the workspace
    - name: kerberosRealm
      type: string
      description: Name of the key used to sign the kernel modules
    - name: signingAuthor
      type: string
      description: Human name responsible for the signing process
    - name: checksumFingerprint
      type: string
      description: Secret containing the host key database for SSH the server running signing
    - name: checksumKeytab
      type: string
      description: Secret containing keytab file for the Kerberos user / server
    - name: signing-secret
      type: string
      description: Secret containing the fields signHost, SignKey and SignUser
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The git repository URL for task and StepAction resolution
      default: https://github.com/konflux-ci/release-service-catalog.git
    - name: taskGitRevision
      type: string
      description: The git revision for task and StepAction resolution
      default: main
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  results:
    - name: sourceDataArtifact
      type: string
      description: Produced trusted data artifact
  volumes:
    - name: bs-keytab
      secret:
        secretName: $(params.checksumKeytab)    
        defaultMode: 0444
    - name: checksum-fingerprint
      secret:
        secretName: $(params.checksumFingerprint)
        defaultMode: 0444
    - name: signing-secret-vol
      secret:
        secretName: $(params.signing-secret)
        defaultMode: 0444
    - name: workdir
      emptyDir: {}
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: sign-files
      image: quay.io/konflux-ci/release-service-utils:02a8ddcd16113371a255fd1ef0a196399d300162
      computeResources:
        limits:
          memory: 512Mi
        requests:
          memory: 512Mi
          cpu: 250m
      volumeMounts:
        - name: checksum-fingerprint
          mountPath: "/etc/sec-checksum"
        - name: bs-keytab
          mountPath: "/etc/sec-keytab"
        - name: signing-secret-vol
          mountPath: "/etc/secrets"
      script: |
        #!/usr/bin/env bash
        set -eu

        signKey="$(cat /etc/secrets/signKey)"
        signHost="$(cat /etc/secrets/signHost)"
        signUser="$(cat /etc/secrets/signUser)"

        set -x

        signedKmodsPath="$(params.signedKmodsPath)"
        signingAuthor="$(params.signingAuthor)"
        # Remove newline in signing variables
        signUser="${signUser//$'\n'/}"
        signHost="${signHost//$'\n'/}"

        echo "Signing OOT modules from $(params.dataDir)/$signedKmodsPath.."
        SIGNED_KMODS_PATH="$(params.dataDir)/$signedKmodsPath"
        SSH_OPTS=(
          -o UserKnownHostsFile=~/.ssh/known_hosts
          -o GSSAPIAuthentication=yes
          -o GSSAPIDelegateCredentials=yes
        )

        # Function to sign kernel modules for a specific architecture
        sign_kmods_for_arch() {
            local arch_name="$1"
            local remote_dir="$HOME/kmods"
            if [ "$arch_name" != "single" ]; then
                remote_dir="$HOME/kmods/$arch_name"
            fi

            signing_author="$signingAuthor"
            export signing_author
            export signKey
            echo "Executing SSH command to sign OOT kernel modules for architecture: $arch_name"
            # shellcheck disable=SC2029  # Intentional client-side expansion
            ssh "${SSH_OPTS[@]}" "${signUser}@${signHost}" \
            "export KEY='${signKey}'; export ARCH='${arch_name}'; export REMOTE_DIR='${remote_dir}'; \
             bash -s" <<'EOF'
        echo "Remote: Signing OOT kernel modules for architecture $ARCH using $KEY key..."
        for kmod in $REMOTE_DIR/*.ko; do
            if [ -f "$kmod" ]; then
                echo "Remote: Signing kernel module $kmod for $ARCH"
                rh-signing-client --key "$KEY" --onbehalfof "${signing_author}" --lkmsign "$kmod"
                if [ $? -ne 0 ]; then
                    echo "Remote: ERROR failed to sign $kmod for $ARCH"
                    exit 1
                fi
            else
                echo "Remote: Skipping entry $kmod (not a regular file or no .ko files found for $ARCH)"
            fi
        done
        echo "Remote: Finished signing process for architecture $ARCH"
        EOF
        }

        # Set up Kerberos and SSH
        KRB5CCNAME=FILE:/tmp/krb5cc_$(id -u)
        export KRB5CCNAME
        kinit -kt /etc/sec-keytab/keytab-build-and-sign.keytab "${signUser}@$(params.kerberosRealm)"

        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        cp /etc/sec-checksum/checksumFingerprint ~/.ssh/known_hosts
        chmod 600 ~/.ssh/known_hosts

        # Check if we have architecture-specific directories (multi-arch) or single-arch
        if [ -f "$(params.dataDir)/arch_count.txt" ]; then
            arch_count=$(cat "$(params.dataDir)/arch_count.txt")
            echo "Processing $arch_count architecture(s) for signing"

            if [ "$arch_count" -gt 1 ]; then
                echo "Multi-architecture signing process"

                # Clean up any existing remote kmods directory
                ssh "${SSH_OPTS[@]}" "${signUser}@${signHost}" "rm -rf ~/kmods && mkdir -p ~/kmods"

                # Process each architecture directory
                for arch_dir in "$SIGNED_KMODS_PATH"/*/; do
                    if [ -d "$arch_dir" ]; then
                        arch_name=$(basename "$arch_dir")
                        echo "Processing signing for architecture: $arch_name"

                        # Backup envfile if present
                        if [ -f "$arch_dir/envfile" ]; then
                            cp "$arch_dir/envfile" "/tmp/envfile.backup.$arch_name"
                        fi

                        # Verify we have .ko files to sign
                        ko_files_found=false
                        if ls "$arch_dir"/*.ko 1> /dev/null 2>&1; then
                            ko_files_found=true
                            ko_count=$(find "$arch_dir" -name "*.ko" -type f | wc -l)
                            echo "Found $ko_count .ko files to sign for $arch_name"
                        else
                            echo "WARNING: No .ko files found for architecture $arch_name, skipping"
                            continue
                        fi

                        if [ "$ko_files_found" = true ]; then
                            # Create architecture-specific directory on signing server
                            # shellcheck disable=SC2029
                            ssh "${SSH_OPTS[@]}" "${signUser}@${signHost}" \
                                "mkdir -p \$HOME/kmods/${arch_name}"

                            # Copy unsigned kmods to signing server for this architecture
                            scp "${SSH_OPTS[@]}" "$arch_dir"/*.ko \
                                "${signUser}@${signHost}:\$HOME/kmods/${arch_name}/"

                            # Sign kmods for this architecture
                            sign_kmods_for_arch "$arch_name"

                            # Copy back signed kmods to workspace
                            # Remove unsigned files first to ensure complete replacement
                            rm -f "$arch_dir"/*.ko
                            scp "${SSH_OPTS[@]}" \
                                "${signUser}@${signHost}:\$HOME/kmods/${arch_name}/*.ko" "$arch_dir/"

                            # Restore envfile
                            if [ -f "/tmp/envfile.backup.$arch_name" ]; then
                                cp "/tmp/envfile.backup.$arch_name" "$arch_dir/envfile"
                            fi

                            # Generate checksums for this architecture
                            echo "Generating checksums for $arch_name .ko files..."
                            cd "$arch_dir"
                            if ls ./*.ko >/dev/null 2>&1; then
                                sha256sum ./*.ko > "signed_kmods_checksums_${arch_name}.txt"
                                echo "Generated checksums for $arch_name:"
                                cat "signed_kmods_checksums_${arch_name}.txt"
                            fi
                            echo "Completed signing for $arch_name"
                        fi
                    fi
                done

                # Create overall signing summary
                echo "Multi-architecture signing summary:" > "$SIGNED_KMODS_PATH/signing_summary.txt"
                echo "Total architectures processed: $arch_count" >> "$SIGNED_KMODS_PATH/signing_summary.txt"
                echo "Signing details:" >> "$SIGNED_KMODS_PATH/signing_summary.txt"

                for arch_dir in "$SIGNED_KMODS_PATH"/*/; do
                    if [ -d "$arch_dir" ]; then
                        arch_name=$(basename "$arch_dir")
                        signed_count=0
                        if ls "$arch_dir"/*.ko 1> /dev/null 2>&1; then
                            signed_count=$(find "$arch_dir" -name "*.ko" -type f | wc -l)
                        fi
                        echo "  $arch_name: $signed_count signed .ko files" >> "$SIGNED_KMODS_PATH/signing_summary.txt"

                        # Verify signature by checking if files have been modified
                        if [ -f "$arch_dir/signed_kmods_checksums_${arch_name}.txt" ]; then
                            echo "    Checksums: verified" >> "$SIGNED_KMODS_PATH/signing_summary.txt"
                        fi
                    fi
                done

                echo "Multi-architecture signing completed. Summary:"
                cat "$SIGNED_KMODS_PATH/signing_summary.txt"

            else
                echo "Single architecture, using existing signing logic"
                cd "$SIGNED_KMODS_PATH"

                # Backup envfile before signing process
                if [ -f "envfile" ]; then
                    cp envfile /tmp/envfile.backup
                fi

                # Copy unsigned kmods to signing server
                ssh "${SSH_OPTS[@]}" "${signUser}@${signHost}" "mkdir -p ~/kmods"
                scp "${SSH_OPTS[@]}" "${SIGNED_KMODS_PATH}"/*.ko "${signUser}@${signHost}:~/kmods/"

                # Sign kmods
                sign_kmods_for_arch "single"

                # Copy back signed kmods to workspace
                rm -f "${SIGNED_KMODS_PATH}"/*.ko
                scp "${SSH_OPTS[@]}" "${signUser}@${signHost}:~/kmods/*.ko" "${SIGNED_KMODS_PATH}"/

                # Restore envfile after signing process
                if [ -f "/tmp/envfile.backup" ]; then
                    cp /tmp/envfile.backup envfile
                fi

                # Generate checksums for signed .ko files
                echo "Generating checksums for signed .ko files..."
                if ls "${SIGNED_KMODS_PATH}"/*.ko >/dev/null 2>&1; then
                    cd "${SIGNED_KMODS_PATH}"
                    sha256sum ./*.ko > signed_kmods_checksums.txt
                    echo "Generated checksums:"
                    cat signed_kmods_checksums.txt
                else
                    echo "ERROR: No .ko files found after signing process"
                    exit 1
                fi
            fi
        else
            echo "No architecture information found, falling back to single-arch logic"
            cd "$SIGNED_KMODS_PATH"

            # Backup envfile before signing process
            if [ -f "envfile" ]; then
                cp envfile /tmp/envfile.backup
            fi

            # Copy unsigned kmods to signing server
            ssh "${SSH_OPTS[@]}" "${signUser}@${signHost}" "mkdir -p ~/kmods"
            scp "${SSH_OPTS[@]}" "${SIGNED_KMODS_PATH}"/*.ko "${signUser}@${signHost}:~/kmods/"

            # Sign kmods
            sign_kmods_for_arch "single"

            # Copy back signed kmods to workspace
            rm -f "${SIGNED_KMODS_PATH}"/*.ko
            scp "${SSH_OPTS[@]}" "${signUser}@${signHost}:~/kmods/*.ko" "${SIGNED_KMODS_PATH}"/

            # Restore envfile after signing process
            if [ -f "/tmp/envfile.backup" ]; then
                cp /tmp/envfile.backup envfile
            fi

            # Generate checksums for signed .ko files
            echo "Generating checksums for signed .ko files..."
            if ls "${SIGNED_KMODS_PATH}"/*.ko >/dev/null 2>&1; then
                cd "${SIGNED_KMODS_PATH}"
                sha256sum ./*.ko > signed_kmods_checksums.txt
                echo "Generated checksums:"
                cat signed_kmods_checksums.txt
            else
                echo "ERROR: No .ko files found after signing process"
                exit 1
            fi
        fi
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
