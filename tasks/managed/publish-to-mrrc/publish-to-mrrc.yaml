---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: publish-to-mrrc
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton task that publishes the maven artifacts to MRRC(maven.repository.redhat.com)
    service. MRRC is used to host maven artifacts of Red Hat Middleware products.
    This task will work with [collect-mrrc-task](../collect-mrrc-params/README.md)
    together to do the MRRC publishment work.
    It accepts the `mrrc.env` file from the
    [collect-mrrc-task](../collect-mrrc-params/README.md)
    and use the variables in it as parameters for the MRRC publishing task.
  params:
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
    - name: mrrcParamFilePath
      description: path of the env file for mrrc parameters to use
      type: string
    - name: charonConfigFilePath
      description: path of the charon config file for charon to consume
      type: string
    - name: charonAWSSecret
      description: the secret name for charon aws credential file
      type: string
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: IMAGE
      description: Reference to the OCI-Artifact that merge step will generate
      type: string
      default: "quay.io/yma/merge-release-test:1.0.0"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
    - name: charonSignCASecret
      description: the secret name for ca files for radas signing
      type: string
  results:
    - name: sourceDataArtifact
      type: string
      description: Produced trusted data artifact
  volumes:
    - name: "charon-aws-vol"
      secret:
        secretName: "$(params.charonAWSSecret)"
    - name: mrrc-workdir
      emptyDir: {}
    - name: workdir
      emptyDir: {}
    - name: "charon-signca-vol"
      secret:
        secretName: "$(params.charonSignCASecret)"
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
    env:
      - name: IMAGE
        value: $(params.IMAGE)
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
    # This is a workaround for a problem observed on Konflux clusters where the
    # a step runs with root user causing a file or folder to not be readable
    # in later steps. There might be solution coming related to the
    # security context constraints on the cluster, but setting this explicitly here
    # should probably be harmless either way.
    securityContext:
      runAsUser: 1001
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: prepare-repo
      image: quay.io/konflux-ci/release-service-utils:02a8ddcd16113371a255fd1ef0a196399d300162
      computeResources:
        limits:
          memory: 256Mi
        requests:
          memory: 256Mi
          cpu: 150m
      script: |
        #!/usr/bin/env bash
        set -eux

        MRRC_FILE="$(params.dataDir)/$(params.mrrcParamFilePath)"
        # shellcheck source=/dev/null
        . "$MRRC_FILE"
        mkdir -p /workdir/mrrc
        cd /workdir/mrrc

        IFS='%' read -ra ADDR <<< "$MRRC_ZIP_REGISTRY"
        for r in "${ADDR[@]}"
        do
          echo "Downloading the maven repo zip $r"
          SOURCE_REPO=${r%%@sha256:*}
          AUTH_FILE=$(mktemp)
          hash=${r##*@sha256:}
          short_hash=${hash:0:6}
          repodir="/workdir/mrrc/$short_hash"
          mkdir -p "$repodir"
          select-oci-auth "${SOURCE_REPO}" > "$AUTH_FILE"
          oras pull --registry-config "$AUTH_FILE" "$r" -o "$repodir"
        done
      volumeMounts:
        - name: mrrc-workdir
          mountPath: "/workdir"
    - name: upload-maven-repo
      image: quay.io/yma/merge-release-test:charon-1.4.0@sha256:cc17c4c727d7f488f5be4eb7463d8604b783608f30fb6216d2711e3a1605ac11
      computeResources:
        limits:
          memory: 1Gi
        requests:
          memory: 1Gi
          cpu: 500m
      script: |
        #!/usr/bin/env bash
        set -eux

        CHARON_CFG_FILE="$(params.dataDir)/$(params.charonConfigFilePath)"
        mkdir -p "/home/charon/.charon"
        cp "$CHARON_CFG_FILE" /home/charon/.charon/charon.yaml

        MRRC_FILE="$(params.dataDir)/$(params.mrrcParamFilePath)"
        # shellcheck source=/dev/null
        . "$MRRC_FILE"

        target=$MRRC_TARGET
        productName=$MRRC_PRODUCT_NAME
        productVersion=$MRRC_PRODUCT_VERSION

        IFS='%' read -ra ADDR <<< "$MRRC_ZIP_REGISTRY"
        mergedir="/workdir/mrrc/merged"
        mkdir -p "$mergedir"

        # Check if have more than one archive to merge
        if [ ${#ADDR[@]} -gt 1 ]; then
          charon merge -p "$productName" -v "$productVersion" -m "${mergedir}/merged.zip" "${ADDR[@]}"
        else
          echo "Skip merging: no more than one archive found, no merge needed"
        fi

        # Check if the merged zip is available, if so push it to the registry, or skip pushing
        if [ -f "${mergedir}/merged.zip" ]; then
          select-oci-auth "$IMAGE" >auth.json
          [ -n "$IMAGE_EXPIRES_AFTER" ] && EXPIRE_LABEL=("--annotation" "quay.expires-after=$IMAGE_EXPIRES_AFTER")
          echo "Pushing image ${IMAGE} to registry"
          if ! retry oras push "$IMAGE" \
            --registry-config auth.json \
            "${EXPIRE_LABEL[@]}" \
            --artifact-type application/vnd.maven+zip "${mergedir}/merged.zip"; then
            echo "Failed to push image ${IMAGE} to registry"
            exit 1
          fi
          if ! digest=$(retry oras resolve --registry-config auth.json "${IMAGE}"); then
            echo "Failed to get digest for ${IMAGE} from registry"
            exit 1
          fi
          echo -n "Push merged zip ${IMAGE}@${digest} successfully"
        else
          echo "The merged maven zip file is not found!"
        fi

        # Check if the digest is available, if so use merged result to sign and upload
        if [ -n "${digest}" ]; then
          merged_registry="${IMAGE}@${digest}"
          echo "Release merged $merged_registry with $productName-$productVersion into $target"

          charon sign -r "$MRRC_AUTHOR" -p "${mergedir}" -k "$MRRC_SIGN_KEY" "$merged_registry"

          if [ ! -f "${mergedir}/merged.zip" ]; then
            echo "No merged.zip file found in ${mergedir}, will not publish."
            exit 1
          fi
          sign_files=("$mergedir"/*.json)
          sign_file=${sign_files[0]}
          if [[ "$sign_file" == "$mergedir/*.json" ]]; then
            echo "No signature result received from radas, will not publish."
            exit 1
          fi
          echo "Release ${mergedir}/merged.zip with $productName-$productVersion into $target"
          charon upload -p "$productName" -v "$productVersion" -t "$target" -l "$sign_file" "${mergedir}/merged.zip"
          exit 0
        fi

        for registry in "${ADDR[@]}"
        do
          echo "Release $registry with $productName-$productVersion into $target"
          hash=${registry##*@sha256:}
          short_hash=${hash:0:6}
          repodir="/workdir/mrrc/$short_hash"

          # start signing of the maven artifacts in maven zip
          charon sign -r "$MRRC_AUTHOR" -p "$repodir" -k "$MRRC_SIGN_KEY" "$registry"

          repo_zips=("$repodir"/*.zip)
          repo_zip=${repo_zips[0]}
          if [[ "$repo_zip" == "$repodir/*.zip" ]]
          then
            echo "No maven repository zip file found, will not publish."
            exit 1
          fi
          sign_files=("$repodir"/*.json)
          sign_file=${sign_files[0]}
          if [[ "$sign_file" == "$repodir/*.json" ]]
          then
            echo "No signature result received from radas, will not publish."
            exit 1
          fi
          echo "Release $repo_zip with $productName-$productVersion into $target"
          charon upload -p "$productName" -v "$productVersion" -t "$target" -l "$sign_file" "$repo_zip"
        done
      volumeMounts:
        - name: "charon-aws-vol"
          mountPath: "/home/charon/.aws"
        - name: mrrc-workdir
          mountPath: "/workdir"
        - name: "charon-signca-vol"
          mountPath: "/home/charon/radasca"
        - name: trusted-ca
          mountPath: /etc/ssl/certs/ca-custom-bundle.crt
          subPath: ca-bundle.crt
          readOnly: true
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
