---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: extract-kmods-from-image
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Tekton task to extract kernel modules from an image in a specific directory.
  params:
    - name: kmodsPath
      type: string
      description: Path for the unsigned .ko files to be extracted from the image
    - name: signedKmodsPath
      type: string
      description: Path to store the extracted file in the workspace
    - name: snapshot
      type: string
      description: The namespaced name (namespace/name) of the snapshot
    - name: snapshotPath
      type: string
      description: Path to the JSON string of the mapped Snapshot spec in the data workspace
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The git repository URL for task and StepAction resolution
      default: https://github.com/konflux-ci/release-service-catalog.git
    - name: taskGitRevision
      type: string
      description: The git revision for task and StepAction resolution
      default: main
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  results:
    - name: sourceDataArtifact
      type: string
      description: Produced trusted data artifact
  volumes:
    - name: workdir
      emptyDir: {}
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
    securityContext:
      runAsUser: 1001
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: detect-architectures
      image: quay.io/konflux-ci/release-service-utils@sha256:f10b4ad888634a7633f76ede29003ce1471aec2b76a7d9e01ad282a3011eb78f
      computeResources:
        limits:
          memory: 256Mi
        requests:
          memory: 256Mi
          cpu: 100m
      script: |
        #!/usr/bin/env bash
        set -ex

        snapshot_json=$(cat "$(params.dataDir)/$(params.snapshotPath)")
        source_image=$(jq -r '.components[0].containerImage' <<< "$snapshot_json")
        echo "Detecting architectures for image: $source_image"

        # Use the existing get-image-architectures utility
        arch_json="$(get-image-architectures "${source_image}")"
        echo "Architecture data: $arch_json"

        # Save architecture information for later steps
        echo "$arch_json" > "$(params.dataDir)/architectures.json"

        # Count architectures and save for later use
        arch_count=$(echo "$arch_json" | jq -s 'length')
        echo "Found $arch_count architecture(s)"
        echo "$arch_count" > "$(params.dataDir)/arch_count.txt"

        # Log architecture details
        echo "$arch_json" | jq -c '.' | while IFS= read -r arch_info; do
            platform_arch=$(echo "$arch_info" | jq -r '.platform.architecture')
            arch_digest=$(echo "$arch_info" | jq -r '.digest')
            echo "  Architecture: $platform_arch, Digest: $arch_digest"
        done
    - name: extract-kmods
      image: quay.io/konflux-ci/release-service-utils@sha256:f10b4ad888634a7633f76ede29003ce1471aec2b76a7d9e01ad282a3011eb78f
      computeResources:
        limits:
          memory: 1Gi
        requests:
          memory: 1Gi
          cpu: 500m
      script: |
        #!/usr/bin/env bash
        set -ex
        export DOCKER_CONFIG

        # Debug: Show what dataDir we're using
        echo "DEBUG: dataDir parameter value: $(params.dataDir)"

        KMODS_PATH=$(params.kmodsPath)
        SIGNED_KMODS_PATH=$(params.signedKmodsPath)
        snapshot_json=$(cat "$(params.dataDir)/$(params.snapshotPath)")
        source_image=$(jq -r '.components[0].containerImage' <<< "$snapshot_json")

        # Read architecture count
        arch_count=$(cat "$(params.dataDir)/arch_count.txt")
        echo "Processing $arch_count architecture(s)"

        # Function to extract kmods for a specific image
        extract_single_arch() {
            local img="$1"
            local dest_dir="$2"
            local arch_name="$3"

            echo "Extracting .ko files from $img to $dest_dir (arch: $arch_name)"

            tmp_dir=$(mktemp -d)
            echo "Copying $img to $tmp_dir..."
            skopeo copy docker://"$img" dir:"$tmp_dir"

            echo "Inspecting layers to find OOT kernel modules and envfile for $arch_name"
            extracted=false

            for LAYER in $(jq -r '.layers[].digest' "$tmp_dir/manifest.json"); do
                LAYER=${LAYER#sha256:}
                # Check if the archive contains the KMODS_PATH directory
                if tar -tf "$tmp_dir/$LAYER" | grep -q "^${KMODS_PATH#/}/"; then
                    echo "Extracting $KMODS_PATH/ from $LAYER for $arch_name..."
                    tar -xf "$tmp_dir/$LAYER" -C "$tmp_dir" "${KMODS_PATH#/}" --no-same-owner

                    mkdir -p "$dest_dir"
                    if ls "$tmp_dir$KMODS_PATH"/*.ko 1> /dev/null 2>&1; then
                        cp -r "$tmp_dir$KMODS_PATH"/*.ko "$dest_dir/"
                        extracted=true
                        ko_count=$(find "$dest_dir" -name "*.ko" -type f | wc -l)
                        echo "Extracted .ko files for $arch_name: $ko_count files"
                    fi

                    echo "Copying envfile to get versions data for $arch_name..."
                    # Also extract envfile if it exists in this layer
                    DRIVERS_DIR="$(dirname "${KMODS_PATH#/}")"
                    ENVFILE_PATH="${DRIVERS_DIR}/envfile"
                    if tar -tf "$tmp_dir/$LAYER" | grep -q "^${ENVFILE_PATH}$"; then
                        tar -xf "$tmp_dir/$LAYER" -C "$tmp_dir" "$ENVFILE_PATH" --no-same-owner
                        cp "$tmp_dir/$ENVFILE_PATH" "$dest_dir/"
                        echo "Extracted envfile for $arch_name"
                    fi
                    break
                else
                    echo "$KMODS_PATH not found in $LAYER, continuing..."
                fi
            done

            rm -rf "$tmp_dir"

            if [ "$extracted" = true ]; then
                echo "Successfully extracted kernel modules for $arch_name"
            else
                echo "WARNING: No kernel modules found for $arch_name"
            fi
        }

        if [ "$arch_count" -eq 1 ]; then
            echo "Single architecture image, using standard extraction"
            # Extract the actual architecture name
            actual_arch=$(jq -r '.platform.architecture' "$(params.dataDir)/architectures.json")
            echo "Architecture: $actual_arch"
            extract_single_arch "$source_image" "$(params.dataDir)/$SIGNED_KMODS_PATH/$actual_arch" "$actual_arch"
        else
            echo "Multi-architecture image detected, processing each architecture separately"

            # Read architecture data and process each one
            arch_data=$(cat "$(params.dataDir)/architectures.json")

            echo "$arch_data" | jq -c '.' | while IFS= read -r arch_info; do
                platform_arch=$(echo "$arch_info" | jq -r '.platform.architecture')
                arch_digest=$(echo "$arch_info" | jq -r '.digest')

                echo "Processing architecture: $platform_arch (digest: $arch_digest)"

                # Create architecture-specific directory
                arch_dir="$(params.dataDir)/$SIGNED_KMODS_PATH/$platform_arch"

                # Extract for this specific architecture using manifest digest
                # Extract the registry and repository from source_image (remove existing digest)
                source_base=$(echo "$source_image" | cut -d'@' -f1)
                arch_specific_image="$source_base@$arch_digest"
                echo "Using architecture-specific image: $arch_specific_image"
                extract_single_arch "$arch_specific_image" "$arch_dir" "$platform_arch"
            done

            # Create a summary of what was extracted
            summary_file="$(params.dataDir)/$SIGNED_KMODS_PATH/extraction_summary.txt"
            echo "Multi-architecture extraction summary:" > "$summary_file"
            echo "Total architectures processed: $arch_count" >> "$summary_file"
            echo "Extraction details:" >> "$summary_file"

            for arch_dir in "$(params.dataDir)/$SIGNED_KMODS_PATH"/*/; do
                if [ -d "$arch_dir" ]; then
                    arch_name=$(basename "$arch_dir")
                    ko_count=0
                    if ls "$arch_dir"/*.ko 1> /dev/null 2>&1; then
                        ko_count=$(find "$arch_dir" -name "*.ko" -type f | wc -l)
                    fi
                    echo "  $arch_name: $ko_count .ko files" >> "$summary_file"

                    # List the specific .ko files found
                    if [ "$ko_count" -gt 0 ]; then
                        echo "    Files:" >> "$summary_file"
                        find "$arch_dir" -name "*.ko" -type f | while read -r ko_file; do
                            echo "      $(basename "$ko_file")" >> "$summary_file"
                        done
                    fi
                fi
            done

            echo "Multi-architecture extraction completed. Summary:"
            cat "$summary_file"
        fi
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
