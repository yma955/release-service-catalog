---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: marketplacesvm-push-disk-images
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton Task to publish VM disk images into various cloud marketplaces using `pubtools-marketplacesvm`.
    
    It currently supports images in `raw` and `vhd` formats for `AWS` and `Azure` respectively.
  params:
    - name: snapshotPath
      type: string
      description: |
        Path to the JSON string of the mapped snapshot spec in the data workspace.
        It must be processed by the "apply-mapping" task first
    - name: cloudMarketplacesSecret
      type: string
      description: Env specific secret containing the marketplaces credentials
    - name: prePush
      type: string
      description: Whether perform a pre-push (true) or not (false). When true it will not publish PROD
      default: false
    - name: concurrentLimit
      type: string
      description: The maximum number of images to be pulled at once
      default: 3
    - name: uploadContainerName
      type: string
      description: The name of the container to upload the images to
      default: "konfluxupload"
    - name: ociStorage
      type: string
      description: The OCI repository where the Trusted Artifacts are stored
    - name: ociArtifactExpiresAfter
      type: string
      description: >
        Expiration date for the trusted artifacts created in the OCI repository.
        An empty string means the artifacts do not expire.
        The format is YYYY-MM-DD
      default: ""
    - name: orasOptions
      type: string
      description: oras options to pass to Trusted Artifacts calls
      default: ""
    - name: sourceDataArtifact
      type: string
      description: >
        The Trusted Artifact URI pointing to the artifact with the application snapshot spec and the release data
    - name: dataDir
      type: string
      description: The location where data will be stored
    - name: trustedArtifactsDebug
      type: string
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      default: ""
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  results:
    - name: sourceDataArtifact
      type: string
      description: >
        The Trusted Artifact URI pointing to the artifact with the application snapshot spec and the release data
  volumes:
    - name: workdir
      emptyDir: {}
    - name: cloud-marketplaces-secret-vol
      secret:
        secretName: $(params.cloudMarketplacesSecret)
        defaultMode: 0444
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true

  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: git
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: pull-and-push-images-to-marketplaces
      image: quay.io/konflux-ci/release-service-utils:02a8ddcd16113371a255fd1ef0a196399d300162
      workingDir: $(params.dataDir)
      computeResources:
        limits:
          memory: 1Gi
        requests:
          memory: 1Gi
          cpu: 450m
      volumeMounts:
        - name: cloud-marketplaces-secret-vol
          mountPath: "/etc/secrets"
      env:
        - name: UPLOAD_CONTAINER_NAME  # pulled by the pubtools-marketplacesvm script.
          value: $(params.uploadContainerName)
      script: |
        #!/usr/bin/env bash
        set -eu

        CLOUD_CREDENTIALS="$(cat /etc/secrets/key)"
        
        # export variables required by the script "marketplacesvm_push_wrapper" in release-service-utils 
        export CLOUD_CREDENTIALS 

        set -x

        # Setup required variables
        SNAPSHOT_JSON=$(jq -c '.' "$(params.dataDir)/$(params.snapshotPath)")
        STARMAP_MAPPING=$(jq -c '[.components[].starmap[]]' <<< "$SNAPSHOT_JSON")
        STARMAP_MAPPING_FILE="$(params.dataDir)/$(dirname "$(params.snapshotPath)")/starmap.yaml"
        yq -p json -o yaml <<< "$STARMAP_MAPPING" > "$STARMAP_MAPPING_FILE"

        BASE_DIR="$(mktemp -d)"
        DISK_IMGS_DIR="${BASE_DIR}/starmap/CLOUD_IMAGES"
        mkdir -p "${DISK_IMGS_DIR}"

        RUNNING_JOBS="\j" # Bash parameter for number of jobs currently running
        NUM_COMPONENTS=$(jq '.components | length' <<< "$SNAPSHOT_JSON")

        prepare_component() { # Expected argument is [component json]
            COMPONENT=$1
            PRODUCT_INFO=$(jq -c '.productInfo' <<< "${COMPONENT}")
            PULLSPEC=$(jq -er '.containerImage' <<< "${COMPONENT}")
            IMG_NAME=$(jq -er '.name' <<< "${COMPONENT}")
            BUILD_NAME=$(jq -er '.productCode' <<< "${PRODUCT_INFO}")
            BUILD_VERSION=$(jq -er '.productVersionName' <<< "${PRODUCT_INFO}")
            BUILD_ARCH=$(jq -er '.staged.files[0].filename' <<< "${COMPONENT}")
            BUILD_ARCH=${BUILD_ARCH%\.*}   # Rstrip on . to remove the extension
            BUILD_ARCH=${BUILD_ARCH##*-}  # Lstrip on - on get the arch
            RESOURCES_JSON='
            {
                "api": "v1",
                "resource": "CloudImage",
                "description": "",
                "boot_mode": "hybrid",
                "build": {},
                "images": []
            }'
            RESOURCES_JSON=$(jq -c \
                            --arg build_name "$BUILD_NAME" \
                            --arg build_arch "$BUILD_ARCH" \
                            --arg build_version "$BUILD_VERSION" \
                            '.build.name=$build_name |
                            .build.arch=$build_arch |
                            .build.version=$build_version' <<< "$RESOURCES_JSON"
            )
            DESTINATION="${DISK_IMGS_DIR}/${IMG_NAME}"
            mkdir -p "${DESTINATION}"
            DOWNLOAD_DIR=$(mktemp -d)
            cd "$DOWNLOAD_DIR"
            # oras has very limited support for selecting the right auth entry,
            # so create a custom auth file with just one entry
            AUTH_FILE=$(mktemp)
            select-oci-auth "${PULLSPEC}" > "$AUTH_FILE"
            oras pull --registry-config "$AUTH_FILE" "$PULLSPEC"
            NUM_MAPPED_FILES=$(jq '.staged.files | length' <<< "${COMPONENT}")
            for ((i = 0; i < NUM_MAPPED_FILES; i++)); do
                FILE=$(jq -c --arg i "$i" '.staged.files[$i|tonumber]' <<< "$COMPONENT")
                SOURCE=$(jq -er '.source' <<< "$FILE")
                FILENAME=$(jq -er '.filename' <<< "$FILE")
                if [ -f "${SOURCE}.gz" ]; then
                    gzip -d "${SOURCE}.gz"
                fi
                if [ -f "${DESTINATION}/${FILENAME}" ]; then
                    echo -n "Multiple files use the same destination value: $DESTINATION" >&2
                    echo " and filename value: $FILENAME. Failing..." >&2
                    exit 1
                fi
                if [ "${FILENAME##*\.}" = "vhd" ]; then
                    image_type="VHD"
                elif [ "${FILENAME##*\.}" = "raw" ]; then
                    image_type="AMI"
                else
                  continue
                fi
                mv "$SOURCE" "${DESTINATION}" || echo "didn't find mapped file: ${SOURCE}"
                RESOURCES_JSON=$(jq --arg filename "$FILENAME" \
                    '.images[.images | length] = {"path": $filename, "architecture": "$arch"}' <<< "$RESOURCES_JSON")
                RESOURCES_JSON=$(jq --arg image_type "$image_type" \
                    '.type = "$image_type"' <<< "$RESOURCES_JSON")
            done
            echo "$RESOURCES_JSON" | yq -P -I 4 > "$DESTINATION/resources.yaml"
        }

        # Process each component in parallel
        for ((i = 0; i < NUM_COMPONENTS; i++)); do
            COMPONENT=$(jq -c --arg i "$i" '.components[$i|tonumber]' <<< "$SNAPSHOT_JSON")
            # Limit batch size to concurrent limit
            while (( ${RUNNING_JOBS@P} >= $(params.concurrentLimit) )); do
                wait -n
            done
            prepare_component "$COMPONENT" &
        done

        # Wait for remaining processes to finish
        while (( ${RUNNING_JOBS@P} > 0 )); do
            wait -n
        done

        # Change to the base directory
        cd "${BASE_DIR}"

        # Validate the staged structure using pushsource-ls
        pushsource-ls "staged:${BASE_DIR}"

        # Process the push
        EXTRA_ARGS=()
        if [[ "$(params.prePush)" == "true" ]]; then
             EXTRA_ARGS+=("--nochannel")
        fi
        marketplacesvm_push_wrapper --debug "${EXTRA_ARGS[@]}" \
            --source "${BASE_DIR}" --starmap-file "$STARMAP_MAPPING_FILE"
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: git
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
