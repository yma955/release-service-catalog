---
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: test-rh-sign-image-multiple-components-already-signed
spec:
  description: |
    Test multiple components to be signed with multiple
    signing keys where some of the images partially signed by
    one key. Expectation is that images alredy signed with one key will be
    signed only by the other one.
  params:
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored.
      type: string
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire.
      type: string
      default: "1d"
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: "--insecure"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable.
      type: string
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
  tasks:
    - name: setup
      taskSpec:
        results:
          - name: sourceDataArtifact
            type: string
        volumes:
          - name: workdir
            emptyDir: {}
        stepTemplate:
          volumeMounts:
            - mountPath: /var/workdir
              name: workdir
          env:
            - name: IMAGE_EXPIRES_AFTER
              value: $(params.ociArtifactExpiresAfter)
            - name: "ORAS_OPTIONS"
              value: "$(params.orasOptions)"
            - name: "DEBUG"
              value: "$(params.trustedArtifactsDebug)"
        steps:
          - name: setup-values
            image: quay.io/konflux-ci/release-service-utils:02a8ddcd16113371a255fd1ef0a196399d300162
            script: |
              #!/usr/bin/env bash
              set -eux

              mkdir -p "$(params.dataDir)/$(context.pipelineRun.uid)"
              cat > "$(params.dataDir)/$(context.pipelineRun.uid)/snapshot_spec.json" << EOF
              {
                "application": "myapp",
                "components": [
                  {
                    "name": "comp0",
                    "containerImage": "registry.io/image0@sha256:0000",
                    "repositories": [
                      {
                        "url": "quay.io/redhat-pending/prod----repo0",
                        "rh-registry-repo": "registry.stage.redhat.io/prod/repo0",
                        "registry-access-repo": "registry.access.stage.redhat.com/prod/repo0",
                        "tags": [
                          "some-prefix-12345",
                          "some-prefix"
                        ]
                      }
                    ]
                  },
                  {
                    "name": "comp1",
                    "containerImage": "registry.io/image1@sha256:0001",
                    "repositories": [
                      {
                        "url": "quay.io/redhat-pending/prod----repo1",
                        "rh-registry-repo": "registry.stage.redhat.io/prod/repo1",
                        "registry-access-repo": "registry.access.stage.redhat.com/prod/repo1",
                        "tags": [
                          "some-prefix-12345",
                          "some-prefix"
                        ]
                      }
                    ]
                  },
                  {
                    "name": "comp2",
                    "containerImage": "registry.io/image2@sha256:0002",
                    "repositories": [
                      {
                        "url": "quay.io/redhat-pending/prod----repo2",
                        "rh-registry-repo": "registry.stage.redhat.io/prod/repo2",
                        "registry-access-repo": "registry.access.stage.redhat.com/prod/repo2",
                        "tags": [
                          "some-prefix-12345",
                          "some-prefix"
                        ]
                      }
                    ]
                  },
                  {
                    "name": "comp3",
                    "containerImage": "registry.io/docker-image3@sha256:0003",
                    "repositories": [
                      {
                        "url": "quay.io/redhat-pending/prod----repo3",
                        "rh-registry-repo": "registry.redhat.io/already/signed",
                        "registry-access-repo": "registry.access.redhat.com/already/signed",
                        "tags": [
                          "some-prefix-12345",
                          "some-prefix"
                        ]
                      }
                    ]
                  }
                ]
              }
              EOF

              cat > "$(params.dataDir)/$(context.pipelineRun.uid)/data.json" << EOF
              {
                "sign": {
                  "configMapName": "signing-config-map-multi-keys"
                },
                "mapping": {
                  "defaults": {
                    "pushSourceContainer": false
                  }
                }
              }
              EOF
              cat > "$(params.dataDir)/$(context.pipelineRun.uid)/release_plan_admission.json" << EOF
              {
                "spec": {
                  "pipeline": {
                    "pipelineRef": {
                      "resolver": "git",
                      "params": [
                        {
                          "name": "url",
                          "value": "https://localhost.git"
                        },
                        {
                          "name": "revision",
                          "value": "main"
                        },
                        {
                          "name": "pathInRepo",
                          "value": "pipelines/abc/abc.yaml"
                        }
                      ]
                    },
                    "serviceAccountName": "release-service-account"
                  }
                }
              }
              EOF

              cat > "$(params.dataDir)/$(context.pipelineRun.uid)/signRegistryAccess.txt" << EOF
              prod/repo0
              prod/repo1
              prod/repo2
              prod/repo3
              EOF
          - name: create-trusted-artifact
            ref:
              name: create-trusted-artifact
            params:
              - name: ociStorage
                value: $(params.ociStorage)
              - name: workDir
                value: $(params.dataDir)
              - name: sourceDataArtifact
                value: $(results.sourceDataArtifact.path)
    - name: run-task
      taskRef:
        name: rh-sign-image
      params:
        - name: requester
          value: testuser-multiple
        - name: pipelineRunUid
          value: $(context.pipelineRun.uid)
        - name: snapshotPath
          value: $(context.pipelineRun.uid)/snapshot_spec.json
        - name: dataPath
          value: $(context.pipelineRun.uid)/data.json
        - name: releasePlanAdmissionPath
          value: $(context.pipelineRun.uid)/release_plan_admission.json
        - name: pyxisSecret
          value: test-create-pyxis-image-cert
        - name: signRegistryAccessPath
          value: $(context.pipelineRun.uid)/signRegistryAccess.txt
        - name: ociStorage
          value: $(params.ociStorage)
        - name: orasOptions
          value: $(params.orasOptions)
        - name: sourceDataArtifact
          value: "$(tasks.setup.results.sourceDataArtifact)=$(params.dataDir)"
        - name: dataDir
          value: $(params.dataDir)
        - name: trustedArtifactsDebug
          value: $(params.trustedArtifactsDebug)
        - name: taskGitUrl
          value: "http://localhost"
        - name: taskGitRevision
          value: "main"
      runAfter:
        - setup
    - name: check-result
      params:
        - name: sourceDataArtifact
          value: "$(tasks.run-task.results.sourceDataArtifact)=$(params.dataDir)"
      taskSpec:
        params:
          - name: sourceDataArtifact
            type: string
        volumes:
          - name: workdir
            emptyDir: {}
        stepTemplate:
          volumeMounts:
            - mountPath: /var/workdir
              name: workdir
          env:
            - name: IMAGE_EXPIRES_AFTER
              value: $(params.ociArtifactExpiresAfter)
            - name: "ORAS_OPTIONS"
              value: "$(params.orasOptions)"
            - name: "DEBUG"
              value: "$(params.trustedArtifactsDebug)"
        steps:
          - name: use-trusted-artifact
            ref:
              name: use-trusted-artifact
            params:
              - name: workDir
                value: $(params.dataDir)
              - name: sourceDataArtifact
                value: $(params.sourceDataArtifact)
          - name: check-result
            image: quay.io/konflux-ci/release-service-utils:02a8ddcd16113371a255fd1ef0a196399d300162
            script: |
              #!/usr/bin/env bash
              set -eux

              internalRequests="$(kubectl get internalrequest -o json --sort-by=.spec.params.manifest_digests | jq -c)"
              irsLength=$(jq ".items | length" <<< "${internalRequests}" )

              for((i=0; i<3; i++)); do
                {
                  echo "registry.stage.redhat.io/prod/repo${i}:some-prefix-12345";
                  echo "registry.access.stage.redhat.com/prod/repo${i}:some-prefix-12345";
                  echo "registry.stage.redhat.io/prod/repo${i}:some-prefix";
                  echo "registry.access.stage.redhat.com/prod/repo${i}:some-prefix";
                } >> /tmp/expected_refs0.txt
                {
                  echo "sha256:000${i}";
                  echo "sha256:000${i}";
                  echo "sha256:000${i}";
                  echo "sha256:000${i}";
                } >> /tmp/expected_digs0.txt
              done

              {
                echo "redhate2etesting";
                echo "redhate2etesting2"
              } >> /tmp/expected_keys0.txt

              sort < /tmp/expected_refs0.txt > /tmp/expected_refs0.sorted
              sort < /tmp/expected_digs0.txt > /tmp/expected_digs0.sorted
              sort < /tmp/expected_keys0.txt > /tmp/expected_keys0.sorted

              {
                echo "registry.redhat.io/already/signed:some-prefix";
                echo "registry.redhat.io/already/signed:some-prefix-12345"
              } >> /tmp/expected_refs1.sorted
              {
                echo "sha256:0003";
                echo "sha256:0003"
              } >> /tmp/expected_digs1.sorted
              echo "redhate2etesting2" >> /tmp/expected_keys1.sorted

              for((ir=0; ir<irsLength; ir++)); do
                params=$(jq -r ".items[$ir].spec.params" <<< "${internalRequests}")
                refsValue=$(jq -r '.references' <<< "${params}")

                for ref in $refsValue; do
                  echo "$ref" >> /tmp/found_refs${ir}.txt
                done

                manifestDigests=$(jq -r '.manifest_digests' <<< "${params}")
                for digest in $manifestDigests; do
                  echo "$digest" >> /tmp/found_digs${ir}.txt
                done

                signing_keys=$(jq -r '.signing_key_names' <<< "${params}")
                for key in $signing_keys; do
                  echo "$key" >> /tmp/found_keys${ir}.txt
                done

                sort < /tmp/found_refs${ir}.txt > /tmp/found_refs${ir}.sorted
                sort < /tmp/found_digs${ir}.txt > /tmp/found_digs${ir}.sorted
                sort < /tmp/found_keys${ir}.txt > /tmp/found_keys${ir}.sorted

                diff -Naur /tmp/expected_refs${ir}.sorted /tmp/found_refs${ir}.sorted
                diff -Naur /tmp/expected_digs${ir}.sorted /tmp/found_digs${ir}.sorted
                diff -Naur /tmp/expected_keys${ir}.sorted /tmp/found_keys${ir}.sorted

                if [ "$(jq -r '.config_map_name' <<< "${params}")" != "signing-config-map-multi-keys" ]
                then
                  echo "config_map_name does not match"
                  exit 1
                fi

                if [ "$(jq -r '.requester' <<< "${params}")" != "testuser-multiple" ]
                then
                  echo "requester does not match"
                  exit 1
                fi

                if [ "$(jq -r '.pipeline_image' <<< "${params}")" != \
                  "quay.io/redhat-isv/operator-pipelines-images:released" ]
                then
                  echo "pipeline_image does not match"
                  exit 1
                fi
              done

      runAfter:
        - run-task
  finally:
    - name: cleanup
      taskSpec:
        steps:
          - name: delete-crs
            image: quay.io/konflux-ci/release-service-utils:02a8ddcd16113371a255fd1ef0a196399d300162
            script: |
              #!/usr/bin/env bash
              set -eux

              kubectl delete internalrequests --all
