---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: update-trusted-tasks
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton task to update trusted-tasks list OCI artifact.
    Once a task is released as a bundle, the list of trusted-tasks should be
    updated with the new task.
    The OCI artifact containing the trusted-tasks list is named `acceptable-data-bundles` and should reside in the same
    org in the registry. If it is already in place, it will be used as an input to which the results will be appended,
    else a new artifact will be created.
  params:
    - name: snapshotPath
      type: string
      description: Path to the JSON string of the Snapshot spec in the data workspace
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: sourceDataArtifact
      description: The source data artifact to use for trusted artifacts
      type: string
      default: ""
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  results:
    - name: sourceDataArtifact
      type: string
      description: Produced trusted data artifact
  volumes:
    - name: workdir
      emptyDir: {}
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
      # This is a workaround for a problem observed on a particular cluster where the
      # use-trusted-artifacts step runs with root user causing a docker credential file
      # to not be readable in later steps. There might be solution coming related to the
      # security context constraints on the cluster, but setting this explicitly here
      # should probably be harmless either way.
    securityContext:
      runAsUser: 1001
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: update-trusted-tasks
      image: quay.io/konflux-ci/appstudio-utils@sha256:99e95382cee33b71b1bed02dff900d62899c719b8718178afd8c5d90a0d169ef
      computeResources:
        limits:
          memory: 1Gi
        requests:
          memory: 1Gi
          cpu: 500m
      script: |
        #!/bin/bash
        set -eux

        SNAPSHOT_SPEC_FILE="$(params.dataDir)/$(params.snapshotPath)"
        TAG="latest"

        # check if snapshot exsits
        if [ ! -f "${SNAPSHOT_SPEC_FILE}" ] ; then
            echo "No valid snapshot file was found."
            exit 1
        fi

        # Extract the application from the snapshot
        application=$(jq -r '.application' "${SNAPSHOT_SPEC_FILE}")

        # Get the number of components
        NUM_COMPONENTS=$(jq '.components | length' "${SNAPSHOT_SPEC_FILE}")

        printf 'Beginning "%s" for "%s"\n\n' "$(context.task.name)" "$application"
        for ((i = 0; i < NUM_COMPONENTS; i++))
        do
            # Extract the component from the snapshot
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_SPEC_FILE}")

            # Extract the image sha
            sha=$(jq -r '.containerImage' <<< "$component" | awk -F'@' '{print "@" $2}')

            # Get the number of repositories from the component
            NUM_REPOSITORIES=$(jq '.repositories | length' <<< "$component")

            # Iterate through each repository in the component
            for ((j = 0; j < NUM_REPOSITORIES; j++))
            do
                # Extract the repository URL from the snapshot
                repository=$(jq -r --argjson j "$j" '.repositories[$j].url' <<< "$component")

                # The data-acceptable-bundles repo should reside in the same org in the registry.
                # Fetch the repository and replace the repo with data-acceptable-bundles
                # for example: quay.io/myorg/myrepo -> quay.io/myorg/data-acceptable-bundles
                ACCEPTABLE_BUNDLES=$(echo "${repository}" \
                  | awk -F'/' '{$NF="data-acceptable-bundles"; print $0}' OFS='/')

                # Get the number of tags from the repository
                NUM_TAGS=$(jq --argjson j "$j" '.repositories[$j].tags | length' <<< "$component")

                # update the tasks list OCI artifact for each tag in the repository
                for ((k = 0; k < NUM_TAGS; k++))
                do
                    imageTag=$(jq -c -r --argjson j "$j" --argjson k "$k" '.repositories[$j].tags[$k]' <<< "$component")

                    set +e
                    # Check if ACCEPTABLE_BUNDLES OCI artifact has a latest tag
                    skopeo list-tags docker://"${ACCEPTABLE_BUNDLES}" | jq -r '.Tags[]' | grep "^${TAG}$" &> /dev/null
                    RESULT=$?
                    set -e

                    # If it has a latest tag, use it as an --input for the ec track bundle command
                    if [ $RESULT -eq 0 ]; then
                        echo "${ACCEPTABLE_BUNDLES}:${TAG} exists - using it as an input"
                        ec track bundle --bundle "${repository}:${imageTag}${sha}" \
                        --input oci:"${ACCEPTABLE_BUNDLES}:${TAG}" --output oci:"${ACCEPTABLE_BUNDLES}:${TAG}"

                    # Else - Do not use it as an --input
                    else
                        echo "${ACCEPTABLE_BUNDLES}:${TAG} does not exist"
                        ec track bundle --bundle "${repository}:${imageTag}${sha}" \
                        --output oci:"${ACCEPTABLE_BUNDLES}:${TAG}"
                    fi
                done
            done
        done
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: "$(params.taskGitUrl)"
          - name: revision
            value: "$(params.taskGitRevision)"
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
