---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: update-trusted-tasks
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton task to update trusted-tasks list OCI artifact.
    Once a task is released as a bundle, the list of trusted-tasks should be
    updated with the new task.
    The OCI artifact containing the trusted-tasks list is named `acceptable-data-bundles` and should reside in the same
    org in the registry. If it is already in place, it will be used as an input to which the results will be appended,
    else a new artifact will be created.
  params:
    - name: snapshotPath
      type: string
      description: Path to the JSON string of the Snapshot spec in the data workspace
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: sourceDataArtifact
      description: The source data artifact to use for trusted artifacts
      type: string
      default: ""
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
    - name: registrySecret
      type: string
      description: The name of the secret with the registry token for making repositories public
      default: "registry-token"
  results:
    - name: sourceDataArtifact
      type: string
      description: Produced trusted data artifact
  volumes:
    - name: registry-secret-vol
      secret:
        secretName: $(params.registrySecret)
    - name: workdir
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
      # This is a workaround for a problem observed on a particular cluster where the
      # use-trusted-artifacts step runs with root user causing a docker credential file
      # to not be readable in later steps. There might be solution coming related to the
      # security context constraints on the cluster, but setting this explicitly here
      # should probably be harmless either way.
    securityContext:
      runAsUser: 1001
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: update-trusted-tasks
      image: quay.io/konflux-ci/appstudio-utils@sha256:8381b83a22b71fe5efad5dcc093352b17a62920743a7b578e2f523eb3f1aef9c
      computeResources:
        limits:
          memory: 1Gi
        requests:
          memory: 1Gi
          cpu: 500m
      script: |
        #!/bin/bash
        set -eux

        SNAPSHOT_SPEC_FILE="$(params.dataDir)/$(params.snapshotPath)"
        TAG="latest"

        # check if snapshot exsits
        if [ ! -f "${SNAPSHOT_SPEC_FILE}" ] ; then
            echo "No valid snapshot file was found."
            exit 1
        fi

        # Extract the application from the snapshot
        application=$(jq -r '.application' "${SNAPSHOT_SPEC_FILE}")

        # Get the number of components
        NUM_COMPONENTS=$(jq '.components | length' "${SNAPSHOT_SPEC_FILE}")

        printf 'Beginning "%s" for "%s"\n\n' "$(context.task.name)" "$application"
        for ((i = 0; i < NUM_COMPONENTS; i++))
        do
            # Extract the component from the snapshot
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_SPEC_FILE}")

            # Extract the image sha
            sha=$(jq -r '.containerImage' <<< "$component" | awk -F'@' '{print "@" $2}')

            # Get the number of repositories from the component
            NUM_REPOSITORIES=$(jq '.repositories | length' <<< "$component")

            # Iterate through each repository in the component
            for ((j = 0; j < NUM_REPOSITORIES; j++))
            do
                # Extract the repository URL from the snapshot
                repository=$(jq -r --argjson j "$j" '.repositories[$j].url' <<< "$component")

                # The data-acceptable-bundles repo should reside in the same org in the registry.
                # Fetch the repository and replace the repo with data-acceptable-bundles
                # for example: quay.io/myorg/myrepo -> quay.io/myorg/data-acceptable-bundles
                ACCEPTABLE_BUNDLES=$(echo "${repository}" \
                  | awk -F'/' '{$NF="data-acceptable-bundles"; print $0}' OFS='/')

                # Get the number of tags from the repository
                NUM_TAGS=$(jq --argjson j "$j" '.repositories[$j].tags | length' <<< "$component")

                # update the tasks list OCI artifact for each tag in the repository
                for ((k = 0; k < NUM_TAGS; k++))
                do
                    imageTag=$(jq -c -r --argjson j "$j" --argjson k "$k" '.repositories[$j].tags[$k]' <<< "$component")

                    set +e
                    # Check if ACCEPTABLE_BUNDLES OCI artifact has a latest tag
                    skopeo list-tags docker://"${ACCEPTABLE_BUNDLES}" | jq -r '.Tags[]' | grep "^${TAG}$" &> /dev/null
                    RESULT=$?
                    set -e

                    # If it has a latest tag, use it as an --input for the ec track bundle command
                    if [ $RESULT -eq 0 ]; then
                        echo "${ACCEPTABLE_BUNDLES}:${TAG} exists - using it as an input"
                        ec track bundle --bundle "${repository}:${imageTag}${sha}" \
                        --input oci:"${ACCEPTABLE_BUNDLES}:${TAG}" --output oci:"${ACCEPTABLE_BUNDLES}:${TAG}"

                    # Else - Do not use it as an --input
                    else
                        echo "${ACCEPTABLE_BUNDLES}:${TAG} does not exist"
                        ec track bundle --bundle "${repository}:${imageTag}${sha}" \
                        --output oci:"${ACCEPTABLE_BUNDLES}:${TAG}"
                    fi
                done
            done
        done
    - name: make-data-acceptable-bundles-public
      image: quay.io/konflux-ci/release-service-utils:a5072c6da901bc9cf4d767da82e700784c7df981
      computeResources:
        limits:
          memory: 256Mi
        requests:
          memory: 256Mi
          cpu: 150m
      volumeMounts:
        - name: registry-secret-vol
          mountPath: "/etc/secrets"
      script: |
        #!/usr/bin/env bash
        set -eu
        REGISTRY_TOKEN="$(cat /etc/secrets/token)"
        set -x
        # Function to call quay.io to make a repository public
        # Parameters:
        # repository: full path to repo on quay.io, e.g. "myorg/myrepo"
        function make_repo_public() {
          set +x
          if curl -X POST \
            --fail-with-body --retry 3 \
            --header "Authorization: Bearer ${REGISTRY_TOKEN}" \
            --header 'Content-Type: application/json' \
            --data '{"visibility": "public"}' \
            "https://quay.io/api/v1/repository/${1}/changevisibility"
          then
            echo "Successfully made quay.io/${1} public"
          else
            echo "Error: Failed to make repo quay.io/${1} public."\
              "Make sure the secret $(params.registrySecret) contains"\
              " the \"token\" key with token that has permission to"\
              " Administer Repositories."
            exit 1
          fi
          set -x
        }
        SNAPSHOT_SPEC_FILE="$(params.dataDir)/$(params.snapshotPath)"
        if [ ! -f "${SNAPSHOT_SPEC_FILE}" ] ; then
            echo "No valid snapshot file was provided."
            exit 1
        fi
        # Extract the application from the snapshot
        application=$(jq -r '.application' "${SNAPSHOT_SPEC_FILE}")
        # Get the number of components
        NUM_COMPONENTS=$(jq '.components | length' "${SNAPSHOT_SPEC_FILE}")
        printf 'Making data-acceptable-bundles repositories public for "%s"\n\n' "$application"
        
        # Track all data-acceptable-bundles repositories that were created/updated
        declare -A processed_repos
        
        for ((i = 0; i < NUM_COMPONENTS; i++))
        do
            # Extract the component from the snapshot
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_SPEC_FILE}")
            # Get the number of repositories from the component
            NUM_REPOSITORIES=$(jq '.repositories | length' <<< "$component")
            # Iterate through each repository in the component
            for ((j = 0; j < NUM_REPOSITORIES; j++))
            do
                # Extract the repository URL from the snapshot
                repository=$(jq -r --argjson j "$j" '.repositories[$j].url' <<< "$component")
                # The data-acceptable-bundles repo should reside in the same org in the registry.
                # Fetch the repository and replace the repo with data-acceptable-bundles
                # for example: quay.io/myorg/myrepo -> quay.io/myorg/data-acceptable-bundles
                ACCEPTABLE_BUNDLES=$(echo "${repository}" \
                  | awk -F'/' '{$NF="data-acceptable-bundles"; print $0}' OFS='/')
                # Only process quay.io repositories and avoid duplicates
                if [[ "$ACCEPTABLE_BUNDLES" == quay.io/* ]] && \
                   [[ -z "${processed_repos[$ACCEPTABLE_BUNDLES]:-}" ]]; then
                    echo "Making data-acceptable-bundles repository $ACCEPTABLE_BUNDLES public..."
                    
                    # Remove quay.io/ prefix for the API call
                    REPO_PATH=${ACCEPTABLE_BUNDLES#quay.io/}
                    REPO_PATH=${REPO_PATH%/} # Remove trailing slash just in case
                    
                    make_repo_public "$REPO_PATH"
                    
                    # Mark this repo as processed to avoid duplicates
                    processed_repos[$ACCEPTABLE_BUNDLES]=1
                fi
            done
        done
        
        echo "Completed making all data-acceptable-bundles repositories public"
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: "$(params.taskGitUrl)"
          - name: revision
            value: "$(params.taskGitRevision)"
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
