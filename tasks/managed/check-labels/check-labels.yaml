---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: check-labels
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton task to ensure that components destination repositories names and cpes match the supplied image labels.
    With enforce parameter set to false, the task will just output warnings whenever the values don't match.
  params:
    - name: dataPath
      description: Path to the JSON string of the merged data to use in the data workspace
      type: string
    - name: snapshotPath
      description: Path to the JSON string of the mapped Snapshot spec in the data workspace
      type: string
    - name: enforce
      description: |-
        If set to true, validation failures will be logged as errors, causing the task to fail.
        If set to false (the default), validation failures will be logged as warnings instead, allowing the task to
        complete successfully
      type: string
      default: "false"
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
  volumes:
    - name: workdir
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
    securityContext:
      runAsUser: 1001
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: enforce-name-label
      image: quay.io/konflux-ci/release-service-utils@sha256:f10b4ad888634a7633f76ede29003ce1471aec2b76a7d9e01ad282a3011eb78f
      computeResources:
        limits:
          memory: 100Mi
        requests:
          memory: 100Mi
          cpu: 10m
      script: |
        #!/usr/bin/env bash
        set -ex

        SNAPSHOT_FILE="$(params.dataDir)/$(params.snapshotPath)"
        if [ ! -f "${SNAPSHOT_FILE}" ] ; then
            echo "No valid snapshot file was provided."
            exit 1
        fi

        fail_or_warn() {
            # Use $* to join all arguments with a single space
            local msg="$*"
            if [ "$(params.enforce)" == "true" ]; then
                echo "Error: ${msg}" >&2
                exit 1
            fi
            echo "Warning: ${msg}" >&2
        }

        # derive namespace/repo from a container image URL
        derive_name_from_url() {
            local url="$1"
            # remove scheme (like docker://), remove registry (first path segment),
            # remove tag or digest (anything after : or @), strip leading slashes
            sed -E 's~^[^/]+://~~; s~^[^/]+/~~; s~[:@].*$~~' <<< "$url" | sed 's#^/*##'
        }

        num_components=$(jq '.components | length' "${SNAPSHOT_FILE}")
        for ((i = 0; i < num_components; i++))
        do
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_FILE}")
            name=$(jq -r '.name' <<< "$component")

            # Fetch the value of the 'name' label from the container's metadata
            name_label=$(jq -r '.metadata.labels? | .[] | select(.name == "name") | .value' <<< "$component" || true)

            # Check if the label was found. It is always required.
            if [[ -z "$name_label" || "$name_label" == "null" ]]; then
              fail_or_warn "Component '$name' is missing the required container label" \
                "'name' in its metadata."
              continue
            fi

            # Fetch canonicalName from the component root
            canonical_name=$(jq -r ".canonicalName // empty" <<< "$component")

            num_repos=$(jq '.repositories | length' <<< "$component")

            if [[ "$num_repos" -eq 1 ]]; then
                # --- SINGLE REPOSITORY LOGIC ---
                # Must match the derived URL name. Component-level canonicalName is ignored.
                url=$(jq -r '.repositories[0].url // empty' <<< "$component")
                if [[ -z "$url" ]]; then
                    echo "Error: Component '$name' repositories[0].url is missing" >&2
                    exit 1
                fi

                derived_name=$(derive_name_from_url "$url")

                if [[ "$name_label" != "$derived_name" ]]; then
                    fail_or_warn "Component '$name' name label ('$name_label') does not match" \
                        "derived name from URL ('$derived_name')"
                fi
            elif [[ "$num_repos" -gt 1 ]]; then
                # --- MULTIPLE REPOSITORY LOGIC ---
                # A component-level canonicalName is REQUIRED and must match the name label.
                if [[ -z "$canonical_name" ]]; then
                    fail_or_warn "Component '$name' has multiple repositories, but is missing the" \
                        "component-level 'canonicalName'."
                    continue
                fi

                if [[ "$name_label" != "$canonical_name" ]]; then
                    fail_or_warn "Component '$name' name label ('$name_label') does not match" \
                        "component-level canonicalName ('$canonical_name')"
                fi
            fi
        done
    - name: enforce-cpe-label
      image: quay.io/konflux-ci/release-service-utils@sha256:f10b4ad888634a7633f76ede29003ce1471aec2b76a7d9e01ad282a3011eb78f
      computeResources:
        limits:
          memory: 100Mi
        requests:
          memory: 100Mi
          cpu: 10m
      script: |
        #!/usr/bin/env bash
        set -ex

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No valid data file was provided."
            exit 1
        fi

        SNAPSHOT_FILE="$(params.dataDir)/$(params.snapshotPath)"

        fail_or_warn() {
            # Use $* to join all arguments with a single space
            local msg="$*"
            if [ "$(params.enforce)" == "true" ]; then
                echo "Error: ${msg}" >&2
                exit 1
            fi
            echo "Warning: ${msg}" >&2
        }

        CPE_DATA=$(jq -r '.releaseNotes.cpe // empty' "${DATA_FILE}")
        if [[ -z "$CPE_DATA" ]]; then
            echo "Error: The required static value 'releaseNotes.cpe' is missing or empty in the data file." >&2
            exit 1
        fi

        num_components=$(jq '.components | length' "${SNAPSHOT_FILE}")

        # Now iterate through components to check the label against the single fetched value
        for ((i = 0; i < num_components; i++))
        do
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_FILE}")
            name=$(jq -r '.name' <<< "$component")

            # Fetch the value of the 'cpe' label from the component's metadata
            cpe_label=$(jq -r '.metadata.labels // [] | .[] | select(.name == "cpe")
                | .value // empty' <<< "$component")

            # Check if the label was found. If not, we skip the enforcement.
            if [[ -z "$cpe_label" ]]; then
              echo "Info: Component '$name' is missing the 'cpe' label. Skipping enforcement."
              continue
            fi

            # Compare the label value with the single data value (CPE_DATA)
            if [[ "$cpe_label" != "$CPE_DATA" ]]; then
                fail_or_warn "Component '$name' 'cpe' label ('$cpe_label') does not match" \
                    "the single required CPE value from the data file ('$CPE_DATA')."
                continue
            fi

            echo "Success: Component '$name' 'cpe' label matches the data file value."
        done
