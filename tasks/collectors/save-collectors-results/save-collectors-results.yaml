---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: save-collectors-results
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    A tekton task that updates the passed CR status with the contents stored in the files in the resultsDir.
  params:
    - name: resourceType
      description: The type of resource that is being patched
      type: string
      default: release
    - name: statusKey
      description: The top level key to overwrite in the resource status
      type: string
      default: collectors
    - name: resource
      description: The namespaced name of the resource to be patched
      type: string
    - name: resultsDirPath
      description: |
        The relative path in the workspace where the collectors results
        are saved to
      type: string
    - name: caTrustConfigMapName
      type: string
      description: The name of the ConfigMap to read CA bundle data from
      default: trusted-ca
    - name: caTrustConfigMapKey
      type: string
      description: The name of the key in the ConfigMap that contains the CA bundle data
      default: ca-bundle.crt
  workspaces:
    - name: data
      description: Workspace where the results directory is stored
  volumes:
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
  stepTemplate:
    volumeMounts:
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
  steps:
    - name: save-collectors-results
      image: quay.io/konflux-ci/release-service-utils:82012e03002128f2a226acb23dc5c6fc1c37f5b6
      script: |
        #!/usr/bin/env bash
        set -ex

        RESULTS_JSON="{}"
        RESULTS_DIR="$(workspaces.data.path)/$(params.resultsDirPath)"
        for resultsFile in $([ -d "$RESULTS_DIR" ] && find "$RESULTS_DIR" -type f); do
            if ! jq . >/dev/null 2>&1 "${resultsFile}" ; then
                echo "Ignoring not JSON file: ${resultsFile}."
                continue
            fi
        
            fileName=$(basename "$resultsFile")
        
            # Check if the file name does NOT match the pattern
            if ! [[ "$fileName" =~ ^(managed|tenant)-([a-zA-Z0-9_-]+)\.json$ ]]; then
                echo "Ignoring invalid file name: $fileName"
            else    
                prefix="${BASH_REMATCH[1]}"
                collector="${BASH_REMATCH[2]}"
        
                # Update RESULTS_JSON with the content of the current file under the correct key
                RESULTS_JSON=$(jq --arg prefix "$prefix" --arg collector "$collector" \
                    --slurpfile content "$resultsFile" \
                    '.[$prefix][$collector] = $content[0]' <<< "$RESULTS_JSON")
            fi
        done

        IFS='/' read -r namespace name <<< "$(params.resource)"

        kubectl --warnings-as-errors=true patch "$(params.resourceType)" -n "$namespace" "$name" \
          --type=merge --subresource status --patch "status: {'$(params.statusKey)':${RESULTS_JSON}}"
